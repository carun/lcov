#!/usr/bin/env perl
#
#   Copyright (c) International Business Machines  Corp., 2002,2012
#
#   This program is free software;  you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or (at
#   your option) any later version.
#
#   This program is distributed in the hope that it will be useful, but
#   WITHOUT ANY WARRANTY;  without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#   General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program;  if not, see
#   <http://www.gnu.org/licenses/>.
#
#
# genhtml
#
#   This script generates HTML output from .info files as created by the
#   geninfo script. Call it with --help and refer to the genhtml man page
#   to get information on usage and available options.
#
#
# History:
#   2002-08-23 created by Peter Oberparleiter <Peter.Oberparleiter@de.ibm.com>
#                         IBM Lab Boeblingen
#        based on code by Manoj Iyer <manjo@mail.utexas.edu> and
#                         Megan Bock <mbock@us.ibm.com>
#                         IBM Austin
#   2002-08-27 / Peter Oberparleiter: implemented frame view
#   2002-08-29 / Peter Oberparleiter: implemented test description filtering
#                so that by default only descriptions for test cases which
#                actually hit some source lines are kept
#   2002-09-05 / Peter Oberparleiter: implemented --no-sourceview
#   2002-09-05 / Mike Kobler: One of my source file paths includes a "+" in
#                the directory name.  I found that genhtml.pl died when it
#                encountered it. I was able to fix the problem by modifying
#                the string with the escape character before parsing it.
#   2002-10-26 / Peter Oberparleiter: implemented --num-spaces
#   2003-04-07 / Peter Oberparleiter: fixed bug which resulted in an error
#                when trying to combine .info files containing data without
#                a test name
#   2003-04-10 / Peter Oberparleiter: extended fix by Mike to also cover
#                other special characters
#   2003-04-30 / Peter Oberparleiter: made info write to STDERR, not STDOUT
#   2003-07-10 / Peter Oberparleiter: added line checksum support
#   2004-08-09 / Peter Oberparleiter: added configuration file support
#   2005-03-04 / Cal Pierog: added legend to HTML output, fixed coloring of
#                "good coverage" background
#   2006-03-18 / Marcus Boerger: added --custom-intro, --custom-outro and
#                overwrite --no-prefix if --prefix is present
#   2006-03-20 / Peter Oberparleiter: changes to custom_* function (rename
#                to html_prolog/_epilog, minor modifications to implementation),
#                changed prefix/noprefix handling to be consistent with current
#                logic
#   2006-03-20 / Peter Oberparleiter: added --html-extension option
#   2008-07-14 / Tom Zoerner: added --function-coverage command line option;
#                added function table to source file page
#   2008-08-13 / Peter Oberparleiter: modified function coverage
#                implementation (now enabled per default),
#                introduced sorting option (enabled per default)
#   April/May 2020 / Henry Cox/Steven Dovich - Mediatek, inc
#                Add support for differential line coverage categorization,
#                date- and owner- binning.
#   June/July 2020 / Henry Cox - Mediatek, inc
#                Add support for differential branch coverage categorization,
#                Add a bunch of navigation features - href to next code block
#                of type T, of type T in date- or owner bin B, etc.
#

use strict;
use warnings;

use File::Basename;
use File::Spec;
use File::Temp qw(tempfile);
use Getopt::Long;
use Digest::MD5 qw(md5_base64);
use Cwd qw/abs_path realpath cwd/;
use DateTime;
use DateTime::Format::W3CDTF;
use FileHandle;
use Carp;
use Storable qw(dclone);
use FindBin;

use lib "$FindBin::Bin/../lib";
use lcovutil qw (set_tool_name define_errors parse_ignore_errors
                 system_no_output
                 ignorable_error info verbose $verbose
                 parse_cov_filters summarize_cov_filters
                 $FILTER_BRANCH_NO_COND $FILTER_LINE_CLOSE_BRACE @cov_filter
                 filterStringsAndComments simplifyCode balancedParens
                 die_handler warn_handler $tool_name);

# Global constants
our $title              = "LCOV - differential code coverage report";
our $tool_dir           = abs_path(dirname($0));
our $lcov_version       = 'LCOV version '.`$tool_dir/get_version.sh --full`;
our $lcov_url           = "http://ltp.sourceforge.net/coverage/lcov.php";
lcovutil::set_tool_name(basename($0));

# Specify coverage rate default precision
our $default_precision = 1;

# Specify coverage rate limits (in %) for classifying file entries
# HI:   $hi_limit <= rate <= 100          graph color: green
# MED: $med_limit <= rate <  $hi_limit    graph color: orange
# LO:          0  <= rate <  $med_limit   graph color: red

# For line coverage/all coverage types if not specified
our $hi_limit = 90;
our $med_limit = 75;

# For function coverage
our $fn_hi_limit;
our $fn_med_limit;

# For branch coverage
our $br_hi_limit;
our $br_med_limit;

# Width of overview image
our $overview_width = 80;

# Resolution of overview navigation: this number specifies the maximum
# difference in lines between the position a user selected from the overview
# and the position the source code window is scrolled to.
our $nav_resolution = 4;

# Clicking a line in the overview image should show the source code view at
# a position a bit further up so that the requested line is not the first
# line in the window. This number specifies that offset in lines.
our $nav_offset = 10;

# Clicking on a function name should show the source code at a position a
# few lines before the first line of code of that function. This number
# specifies that offset in lines.
our $func_offset = 2;

our $overview_title = "top level";

# Width for line coverage information in the source code view
our $line_field_width = 12;

# Width for branch coverage information in the source code view
our $br_field_width = 16;

# Internal Constants

# Header types
our $HDR_DIR            = 0;
our $HDR_FILE           = 1;
our $HDR_SOURCE         = 2;
our $HDR_TESTDESC       = 3;
our $HDR_FUNC           = 4;

# Sort types
our $SORT_FILE          = 0;
our $SORT_LINE          = 1;
our $SORT_FUNC          = 2;
our $SORT_BRANCH        = 3;

# Fileview heading types
our $HEAD_NO_DETAIL     = 1;
our $HEAD_DETAIL_HIDDEN = 2;
our $HEAD_DETAIL_SHOWN  = 3;

# Additional offsets used when converting branch coverage data to HTML
our $BR_LEN     = 3;
our $BR_OPEN    = 4;
our $BR_CLOSE   = 5;

# Branch data combination types
our $BR_SUB = 0;
our $BR_ADD = 1;

# Error classes which users may specify to ignore during processing
our $ERROR_SOURCE        = 0;
our $ERROR_UNMAPPED_LINE = 1;
our $ERROR_UNKNOWN_CATEGORY = 2;
our %htmlErrs = (
        "source"   => $ERROR_SOURCE,
        "unmapped" => $ERROR_UNMAPPED_LINE,
        "category" => $ERROR_UNKNOWN_CATEGORY,
);
lcovutil::define_errors(\%htmlErrs);


# Data related prototypes
sub print_usage(*);
sub gen_html();
sub html_create($$);
sub process_dir($);
sub process_file($$$);
sub get_info_entry($);
sub set_info_entry($$$$$$$$$;$$$$$$);
sub get_prefix($@);
sub shorten_prefix($);
sub get_dir_list(@);
sub get_relative_base_path($);
sub read_testfile($);
sub get_date_string($);
sub create_sub_dir($);
sub subtract_counts($$);
sub add_counts($$);
sub apply_baseline($$);
sub remove_unused_descriptions();
sub get_found_and_hit($);
sub get_affecting_tests($$$);
sub combine_info_files($$);
sub merge_checksums($$$);
sub combine_info_entries($$$);
sub apply_prefix($@);
sub read_config($);
sub apply_config($);
sub get_html_prolog($);
sub get_html_epilog($);
sub write_dir_page($$$$$$$$$$$$$);
sub classify_rate($$$$);
sub combine_brcount($$$;$);
sub get_br_found_and_hit($);
sub parse_dir_prefix(@);
sub rate($$;$$$);
sub strip_directories($$);

# HTML related prototypes
sub escape_html($);
sub get_bar_graph_code($$$);

sub write_png_files();
sub write_htaccess_file();
sub write_css_file();
sub write_description_file($$);
sub write_function_table(*$$$$$$$$$$);

sub write_html(*$);
sub write_html_prolog(*$$);
sub write_html_epilog(*$;$);

sub write_header(*$$$$$);
sub write_header_prolog(*$);
sub write_header_line(*@);
sub write_header_epilog(*$);

sub write_file_table(*$$$$$$$);
sub write_file_table_prolog(*$$@);
sub write_file_table_entry(*$$@);
sub write_file_table_detail_entry(*$@);
sub write_file_table_epilog(*);

sub write_test_table_prolog(*$);
sub write_test_table_entry(*$$);
sub write_test_table_epilog(*);

sub write_source($$$$$$$);
sub write_source_prolog(**);
sub write_source_line(*$$$$);
sub write_source_epilog(*);

sub write_frameset(*$$$);
sub write_overview_line(*$$$);
sub write_overview(*$$$$);

# External prototype (defined in genpng)
sub gen_png($$$@);


package SummaryInfo;

our @tlaPriorityOrder = (
    "UNC",
    "LBC",
    "UIC",
    "UBC",

    "GBC",
    "GIC",
    "GNC",
    "CBC",

    "EUB",
    "ECB",
    "DUB",
    "DCB",
    );

our %tlaLocation = (
    "UNC" => 1,
    "LBC" => 3,
    "UIC" => 3,
    "UBC" => 3,

    "GBC" => 3,
    "GIC" => 3,
    "GNC" => 1,
    "CBC" => 3,

    "EUB" => 3,
    "ECB" => 3,
    "DUB" => 2,
    "DCB" => 2,
);

our %tlaToTitle = (
    "UNC" => "Uncovered New Code",
    "LBC" => "Lost Baseline Coverage",
    "UIC" => "Uncovered Included Code",
    "UBC" => "Uncovered Baseline Code",

    "GBC" => "Gain Baseline Coverage",
    "GIC" => "Gain Included Coverage",
    "GNC" => "Gain New Coverage",
    "CBC" => "Covered Baseline Code",

    "EUB" => "Excluded Uncovered Baseline",
    "ECB" => "Excluded Covered Baseline",
    "DUB" => "Deleted Uncovered Baseline",
    "DCB" => "Deleted Covered Baseline",
    );

our %tlaColor = (
    "UBC" => "#FDE007",
    "GBC" => "#448844",
    "LBC" => "#CC6666",
    "CBC" => "#CAD7FE",
    "GNC" => "#B5F7AF",
    "UNC" => "#FF6230",
    "ECB" => "#CC66FF",
    "EUB" => "#DDDDDD",
    "GIC" => "#30CC37",
    "UIC" => "#EEAA30",
    # we don't actually use a color for deleted code.
    #  ... it is deleted.  Does not appear
    "DUB" => "#FFFFFF",
    "DCB" => "#FFFFFF",
    );

our @defaultCutpoints = ( 7, 30, 180 );
our @cutpoints;
our @ageGroupHeader;

sub _initCounts {
    my ($self, $type) = @_;

    my $hash;
    if (defined($type)) {
        $self->{$type} = {};
        $hash = $self->{$type};
    } else {
        $hash = $self;
    }

    foreach my $key ('found', 'hit', 'GNC', 'UNC', 'CBC', 'GBC', 'LBC',
                     'UBC', 'ECB', 'EUB', 'GIC', 'UIC', 'DCB', 'DUB') {
        $hash->{$key} = 0;
    }
}

sub setAgeGroups {
    #my $numGroups = scalar(@_) + 1;
    @cutpoints = sort({$a <=> $b} @_);
    @ageGroupHeader = ();
    my $prefix = "[..";
    foreach my $days (@cutpoints) {
        my $header = $prefix . $days . "] days";
        push(@ageGroupHeader, $header);
        $prefix = "(" . $days . ",";
    }
    push(@ageGroupHeader, "(" . $cutpoints[-1] . "..) days");
}

sub findAgeBin {
  my $age = shift;
  defined($age) or die("undefined age");
  my $bin;
  for ($bin=0 ; $bin <= $#cutpoints ; $bin++) {
    last
      if ($age <= $cutpoints[$bin]);
  }
  return $bin;
}

sub new {
  my ($class, $type, $name) = @_;
  my $self = {};
  bless $self, $class;

  # 'type' expected to be one of 'file', 'directory', 'top'
  $self->{type} = $type;
  $self->{name} = $name;
  defined($name) || $type eq 'top' or
      die("SummaryInfo name should be defined, except at top-level");
  if ($type ne "file") {
      $self->{sources} = {};
  }

  _initCounts($self, 'line');
  _initCounts($self, 'function');
  _initCounts($self, 'branch');

  for my $prefix ("", "branch_") {
    my $g = $prefix . "age";
    $self->{$g} = [ ];
    foreach my $i (0..$#cutpoints + 1) {
      $self->{$g}->[$i] = { _LB => ($i == 0) ? undef : $cutpoints[$i-1],
                            _UB => ($i == $#cutpoints + 1) ? undef : $cutpoints[$i],
                            _INDEX => $i };
      _initCounts($self->{$g}->[$i]);
    }
  }

  $self->{owners} = {}; # developer -> hash of TLA->count - lineCov data
  $self->{owners_branch} = {}; # developer -> hash of TLA->count - branchCov

  return $self;
}

sub get {
    my ($self, $key, $type) = @_;
    $type = 'line'
        if !defined($type);

    my $hash = $self->{$type};
    if ($key eq "total") { return $hash->{found}; }
    else {
        die("ERROR:  unexpected 'get' key $key")
            unless exists($hash->{$key});
        return $hash->{$key};
    }
}

sub owners {
    # return possibly empty list of line owners in this file
    #   - filter only those which have 'missed' lines
    my ($self, $showAll) = @_;

    my @rtn;
  OWNER:
    foreach my $name (keys(%{$self->{owners}})) {
        if ($showAll) {
            push(@rtn, $name);
        }
        else {
            my $h = $self->{owners}->{$name};
            foreach my $tla ('UNC', 'UBC', 'UIC', 'LBC') {
                if (exists($h->{$tla})) {
                    die("unexpected 0 (zero) value for $tla of $name in $self->path()")
                        if (0 == $h->{$tla});
                    push(@rtn, $name);
                    next OWNER;
                }
            }
        }
    }
    return @rtn;
}

sub owner_tlaCount {
    my ($self, $name, $tla, $covType) = @_;
    die("$name not found in owner data for $self->path()")
        unless exists($self->{owners}->{$name});
    my $ownerKey = 'owners';
    $ownerKey .= "_$covType"
      if defined($covType) && $covType ne 'line';
    my $hash = $self->{$ownerKey}->{$name};
    return $hash->{$tla}
      if (exists($hash->{$tla}));

    if ($tla eq "total" ||
        $tla eq "found" ) {
        my $total = 0;
        foreach my $k (keys(%$hash)) {
            # count only code that can be hit (ie., not excluded)
            $total += $hash->{$k}
              if ('EUB' ne $k &&
                  'ECB' ne $k);
        }
        return $total;
    } elsif ($tla eq "hit") {
        my $hit = 0;
        foreach my $k ('CBC', 'GBC', 'GIC', 'GNC') {
            $hit += $hash->{$k}
              if (exists($hash->{$k}));
        }
        return $hit;
    } elsif ($tla eq "missed" ||
             $tla eq "not_hit" ) {
        my $missed = 0;
        foreach my $k ('UBC', 'UNC', 'UIC', 'LBC') {
            $missed += $hash->{$k}
              if (exists($hash->{$k}));
        }
        return $tla eq "missed" ? $missed : -$missed;
    }
    die("unexpected TLA $tla")
        unless exists($tlaLocation{$tla});
    return 0;
}

sub hasOwnerInfo {
  my $self = shift;

  return %{$self->{owners}} ? 1 : 0;
}

sub hasDateInfo {
  my $self = shift;
  # we get date- and owner information at the same time from the
  #  annotation-script - so, if we have owner info, then we have date info too.
  return scalar(%{$self->{owners}});
}

sub findOwnerList {
  # return [ [owner, lineCovData, branchCovData][ for each owner
  #  where lineCovData = [missedCount, totalCount]
  #        branchCovData = [missed, total] or undef if not enabled
  #   - sorted in decending order number of missed lines
  my ($self, $all) = @_;

  my @owners;
  foreach my $owner (keys(%{$self->{owners}})) {
    my $lineMissed = $self->owner_tlaCount($owner, 'missed');
    my $branchMissed = $main::br_coverage ? $self->owner_tlaCount($owner, 'missed', 'branch') : 0;
    # filter owners who have unexercised code, if requested

    if ((0 != $lineMissed || 0 != $branchMissed) ||
        $all) {
        my $lineTotal = $self->owner_tlaCount($owner, 'found');
        my $branchTotal = $main::br_coverage ? $self->owner_tlaCount($owner, 'found', 'branch') : 0;
        push(@owners, [$owner, [$lineMissed, $lineTotal], [$branchMissed, $branchTotal]]);
    }
  }
  @owners = sort({ $b->[1]->[0] <=> $a->[1]->[0] || # missed
                   $b->[1]->[1] <=> $a->[1]->[1] || # then total
                   $a->[0] cmp $b->[0] } @owners); # then by name
  return scalar(@owners) ? \@owners : undef;
}

sub append {
  my ($self, $record) = @_;

  # keep track of the records that get merged into me..
  defined($record->{name}) or
      die("attempt to anonymous SummaryInfo record");
  ! exists($self->{sources}->{$record->{name}}) or
      die("duplicate merge record " . $record->{name});
  $self->{sources}->{$record->{name}} = $record;

  foreach my $group ("line", "function", "branch") {
    foreach my $key (keys %{$self->{$group}}) {
      $self->{$group}->{$key} += $record->{$group}->{$key};
    }
  }

  # there will be no date info if we didn't also collect owner data
  #   merge the date- and owner data, if if we aren't going to display it
  #   (In future, probably want to serialize the data for future processing)
  if (%{$record->{owners}}) {
    foreach my $covType ("line", "branch") {
      for (my $bin = 0 ; $bin <= $#ageGroupHeader ; ++ $bin) {
        foreach my $key (keys %{$self->{$covType}}) {
          # duplicate line-coverage buckets
          my $ageval = $self->age_sample($bin);
          if ($covType eq 'line') {
            $self->lineCovCount($key, "age", $ageval,
                                $record->lineCovCount($key, "age", $ageval));
          } else {
            $self->branchCovCount($key, "age", $ageval,
                                $record->branchCovCount($key, "age", $ageval));
          }
        }
      }
      my $ownerKey = "owners";
      $ownerKey .= "_$covType" if ('line' ne $covType);

      foreach my $name (keys(%{$record->{$ownerKey}})) {
        my $yours = $record->{$ownerKey}->{$name};
        if (! exists($self->{$ownerKey}->{$name})) {
          $self->{$ownerKey}->{$name} = {};
        }
        my $mine = $self->{$ownerKey}->{$name};

        foreach my $tla (keys(%$yours)) {
          my $count = exists($mine->{$tla}) ? $mine->{$tla} : 0;
          $count += $yours->{$tla};
          $mine->{$tla} = $count;
        }
      }
    }
  }
  return $self;
}

sub age_sample {
  my $self = shift;
  my $i = shift;
  my $bin = $self->{age}->[$i];
  return ($i < $#ageGroupHeader) ? $bin->{_UB} : ($bin->{_LB} + 1);
}

sub lineCovCount {
  my $self = shift;
  my $key = shift;
  my $group = shift;
  my $age = ($group eq "age") ? shift : undef;
  my $delta = defined($_[0]) ? shift : 0;

  $key = 'found' if $key eq 'total';
  if ($group eq "age") {
    my $a = $self->{age};
    my $bin = SummaryInfo::findAgeBin($age);
    exists($a->[$bin]) && exists($a->[$bin]->{$key})
      or die("unexpected key");
    $a->[$bin]->{$key} += $delta;
    return $a->[$bin]->{$key};
  }

  defined($self->{$group})
    or die("SummaryInfo::value: unrecognized group $group\n");
  defined($self->{$group}->{$key})
    or die("SummaryInfo::value: unrecognized key $key\n");

  $self->{$group}->{$key} += $delta;
  return $self->{$group}->{$key};
}

sub branchCovCount {
  my $self = shift;
  my $key = shift;
  my $group = shift;
  my $age = ($group eq "age") ? shift : undef;
  my $delta = defined($_[0]) ? shift : 0;

  $key = 'found' if $key eq 'total';
  my $g = "branch_" . $group;
  if ($group eq "age") {
    my $a = $self->{$g};
    my $bin = SummaryInfo::findAgeBin($age);
    exists($a->[$bin]) && exists($a->[$bin]->{$key})
      or die("unexpected key");
    $a->[$bin]->{$key} += $delta;
    return $a->[$bin]->{$key};
  }
  defined($self->{$g})
    or die("SummaryInfo::value: unrecognized branch group $group\n");
  defined($self->{$g}->{$key})
    or die("SummaryInfo::value: unrecognized branch key $key\n");

  $self->{$g}->{$key} += $delta;
  return $self->{$g}->{$key};
}

sub l_found {
  my $self = shift;
  my $delta = defined($_[0]) ? shift : 0;

  $self->{line}->{found} += $delta;
  return $self->{line}->{found};
}

sub l_hit {
  my $self = shift;
  my $delta = defined($_[0]) ? shift : 0;

  $self->{line}->{hit} += $delta;
  return $self->{line}->{hit};
}

sub f_found {
  my $self = shift;
  my $delta = defined($_[0]) ? shift : 0;

  $self->{function}->{found} += $delta;
  return $self->{function}->{found};
}

sub f_hit {
  my $self = shift;
  my $delta = defined($_[0]) ? shift : 0;

  $self->{function}->{hit} += $delta;
  return $self->{function}->{hit};
}

sub b_found {
  my $self = shift;
  my $delta = defined($_[0]) ? shift : 0;

  $self->{branch}->{found} += $delta;
  return $self->{branch}->{found};
}

sub b_hit {
  my $self = shift;
  my $delta = defined($_[0]) ? shift : 0;

  $self->{branch}->{hit} += $delta;
  return $self->{branch}->{hit};
}


package OwnerDetailCallback;
# somewhat of a hack...I want a class which has a callback 'get'
#  that matches the SummaryInfo::get method - but returns owner-specific
#  information
sub new {
  my ($class, $summary, $owner, $covType) = @_;
  $covType = 'line' unless defined($covType);

  my $self = [$summary, $owner, $covType];
  bless $self, $class;
  return $self;
}

sub get {
  my ($self, $key, $type) = @_;

  my ($summary, $owner, $covType) = @$self;

  die("unexpected type $type")
    unless (! defined($type) || ($type eq $covType));

  return $summary->owner_tlaCount($owner, $key, $covType);
}

sub owner {
  my $self = shift;
  return $self->[1];
}

sub covType {
  my $self = shift;
  return $self->[2];
}


package DateDetailCallback;
# as above:  callback class to return date-specific TLA counts
sub new {
  my ($class, $summary, $age, $covType) = @_;
  $covType = 'line' unless defined($covType);

  my $self = [$summary, $age, $covType, SummaryInfo::findAgeBin($age)];
  bless $self, $class;
  return $self;
}

sub get {
  my ($self, $key, $type) = @_;

  my ($summary, $age, $covType) = @$self;

  die("unexpected type $type")
    unless (! defined($type) || ($type eq $covType));

  return $summary->lineCovCount($key, 'age', $age)
    if $covType eq 'line';

  die('function coverage not yet implemented') if $covType ne 'branch';

  return $summary->branchCovCount($key, 'age', $age);
}

sub age {
  my $self = shift;
  return $self->[1];
}

sub bin {
  my $self = shift;
  return $self->[3];
}

sub covType {
  my $self = shift;
  return $self->[2];
}

package BranchCovSummaryCallback;
# callback class to return total branches in each TLA categroy
sub new {
  my ($class, $summary) = @_;
  my $self = [$summary];
  bless $self, $class;
  return $self;
}

sub get {
  my ($self, $key) = @_;

  return $self->[0]->get($key, 'branch');
}

sub owner {
  my $self = shift;
  return $self->[0]->owner();
}

sub age {
  my $self = shift;
  return $self->[0]->age();
}

sub bin {
  my $self = shift;
  return $self->[0]->bin();
}

sub covType {
  my $self = shift;
  return 'branch';
}


package PrintCallback;
# maintain some callback data from one line to the next

sub new {
  my ($class, $sourceFileStruct, $lineCovInfo) = @_;
  my $self = {};
  bless $self, $class;

  $self->{fileInfo} = $sourceFileStruct;
  $self->{lineData} = $lineCovInfo;
  $self->{currentTLA} = "";
  $self->{_owner} = "";
  $self->{_age} = "";
  $self->{_nextOwnerHeader} = {}; # next header line for corresponding owner
  $self->{_nextDateHeader} = {}; # next header line for corresponding date bin
  $self->{_lineNo} = undef;
  return $self;
}

sub sourceDetail {
    my $self = shift;
    return $self->{fileInfo};
}

sub lineData {
  my $self = shift;
  return $self->{lineData};
}

sub lineNo {
  my ($self, $lineNo) = @_;
  $self->{_lineNo} = $lineNo
    if defined($lineNo);
  return $self->{_lineNo};
}

sub tla {
    my $self = shift;
    my $newTLA = shift;
    my $lineNo = shift;
    # NOTE:  'undef' TLA means that this line is not code (it is a comment,
    #    blank line, opening brace or something).
    # We return 'same' as previous line' in that case so the category
    #   block can be larger (e.g., 1 CBC line, a 2 line comment, then 3 more
    #   lines) can get just one label (first line).
    # This reduces visual clutter.
    # Note that the 'block finding' code has to do the same thing (else the
    #   HTML links won't be generated correctly)
    if ( defined($newTLA) &&
         $newTLA ne $self->{currentTLA} ) {
        $self->{currentTLA} = $newTLA;
        return $newTLA;
    }
    return "   "; # same TLA as previous line.
}

sub age {
  my $self = shift;
  my $newval = shift;
  my $lineNo = shift;
  if ( defined($newval) && $newval ne $self->{_age} ) {
    $self->{_age} = $newval;
    return $newval;
  }
  return " "x5; # same age as previous line.
}

sub owner {
    my $self = shift;
    my $newval = shift;
    my $lineNo = shift;
    if ( defined($newval) && $newval ne $self->{_owner} ) {
        $self->{_owner} = $newval;
        return $newval;
    }
    return " "x20; # same age as previous line.
}

sub current {
  my ($self, $key) = @_;

  if ($key eq 'tla') {
    return $self->{currentTLA};
  } elsif ($key eq 'owner') {
    return $self->{_owner};
  } elsif ($key eq 'age') {
    return $self->{_age};
  } else {
    ($key eq 'dateBucket')
        or die("unexpected key $key");
    return SummaryInfo::findAgeBin($self->{_age});
  }
}

sub nextOwner {
  my ($self, $owner, $tla, $value) = @_;
  my $map = $self->{_nextOwnerHeader};

  my $key = $tla . ' ' . $owner;
  if (defined($value)) {
    $map->{$key} = $value;
    return $value;
  }
  return exists($map->{$key}) ? $map->{$key} : undef;
}

sub nextDate {
  my ($self, $date, $tla, $value) = @_;
  my $map = $self->{_nextDateHeader};
  my $key = $tla . ' ' . $date;
  if (defined($value)) {
    $map->{$key} = $value;
    return $value;
  }
  return $map->{$key};
}


package ReadBaselineSource;

sub new {
  my ($class, $diffData) = @_;

  my $self = [$diffData, ReadCurrentSource->new()];
  bless $self, $class;
  return $self;
}

sub open {
  my ($self, $filename) = @_;

  $self->[1]->open($filename, "baseline ");
  $self->[1]->notEmpty()
      or die("unable to read baseline '$filename'");
  $self->[2] = $filename;
}

sub close {
  my $self = shift;
  $self->[1]->close();
}

sub notEmpty {
  my $self = shift;
  return $self->[1]->notEmpty();
}

sub filename {
  return $_[0]->[2];
}

sub getLine {
  my ($self, $line) = @_;
  my ($map, $reader, $filename) = @$self;
  my $type = $map->type($filename, "old", $line);
  if ( $type ne 'delete') {
    my $currLine = $map->lookup($filename, "old", $line);
    return $reader->getLine($currLine);
  } else {
    # deleted line...we don't really care what it looked line
    #  return empty - so the line gets treated as not conditional
    return undef;
  }
}

sub isCloseBrace {
  my ($self, $line) = @_;
  my ($map, $reader, $filename) = @$self;
  my $type = $map->type($filename, "old", $line);
  if ( $type ne 'delete') {
    my $currLine = $map->lookup($filename, "old", $line);
    return $reader->isCloseBrace($currLine);
  } else {
    return 0;
  }
}

sub containsConditional {
  my ($self, $line) = @_;
  my ($map, $reader, $filename) = @$self;
  my $type = $map->type($filename, "old", $line);
  if ( $type ne 'delete') {
    my $currLine = $map->lookup($filename, "old", $line);
    return $reader->containsConditional($currLine);
  } else {
    return 1; # we don't know - so just go with what gcov said
  }
}


package LineData;
sub new {
  my ($class, $type) = @_;
  # [ type, lineNo_base, lineNo_current,
  #   bucket, base_count, curr_count    <- line coverage count data
  #   base_branch, curr_branch, differential_branch ] <- branch coverage count data
  # $type in ('insert', 'equal', 'delete')
  my $self = [$type, undef, undef, 'UNK', 0, 0, undef, undef, undef];
  bless $self, $class;
  return $self;
}

sub tla {
  my ($self, $tla) = @_;
  $self->[3] = $tla
    if defined($tla);
  return $self->[3];
}

sub type {
  my $self = shift;
  return $self->[0];
}

sub lineNo {
  my ($self, $which, $lineNo) = @_;
  my $loc;
  if ($which eq "current") {
    $loc = 2;
  } else {
      die("unknown key $which - should be 'base' or 'current'")
          unless $which eq "base";
      $loc = 1;
  }
  die("inconsistent $which line location: " . $self->[$loc] . " -> $lineNo")
    if (defined($lineNo) && defined($self->[$loc]) && $self->[$loc] != $lineNo);

  $self->[$loc] = $lineNo
    if defined($lineNo);
  return $self->[$loc];
}

sub in_base {
  # @return true or false:  is this object present in the baseline?
  my $self = shift;
  return defined($self->[1]);
}
sub in_curr {
  # @return true or false:  is this object present in the current version?
  my $self = shift;
  return defined($self->[2]);
}

sub base_count {
  # return line hit count in baseline
  my ($self, $inc) = @_;
  die("non-zero count but not in base")
    if (defined($inc) && ! defined($self->[1]));
  $self->[4] += $inc
      if defined($inc);

  return $self->[4];
}

sub curr_count {
  # return line hit count in current
  my ($self, $inc) = @_;
  die("non-zero count but not in current")
    if (defined($inc) && ! defined($self->[3]));
  $self->[5] += $inc
    if defined($inc);

  return $self->[5];
}

sub _mergeBranchData {
  my ($self, $loc, $branchData) = @_;
  if (defined($self->[$loc])) {

    my $current = $self->[$loc];
    foreach my $branchId ($current->blocks()) {
      $branchData->hasBlock($branchId)
        or die("missing branch ID $branchId for line " . $self->lineNo());
      my $c = $current->getBlock($branchId);
      my $d = $branchData->getBlock($branchId);
      scalar(@$c) ==  scalar(@$d)
        or die("inconsistent data for branch ID $branchId for line " .
               $self->lineNo());
      for (my $i = scalar(@$c)-1 ; $i >= 0 ; --$i) {
        my $taken = $d->[$i];
        if ('-' eq $c->[$i]) {
          $c->[$i] = $taken;
        } elsif ('-' ne $taken) {
          $c->[$i] += $taken;
        }
      }
    }
  } else {
    $self->[$loc] = Storable::dclone($branchData);
  }
}

sub baseline_branch {
  my ($self, $branchData) = @_;
  die("has baseline branch data but not in baseline")
    if (defined($branchData) && ! defined($self->[1]));
  if (defined($branchData)) {
    $self->_mergeBranchData(6, $branchData);
  }
  return $self->[6];
}

sub current_branch {
  my ($self, $branchData) = @_;
  die("has baseline branch data but not in current")
    if (defined($branchData) && ! defined($self->[2]));
  if (defined($branchData)) {
    $self->_mergeBranchData(7, $branchData);
  }
  return $self->[7];
}

sub differential_branch {
  my ($self, $differential) = @_;
  if (defined($differential)) {
    $self->[8] = $differential;
  }
  return $self->[8];
}


# structure holding coverage data which has an associated line number:
#   - line coverage
#   - branch coverage
package LineCoverageInfo;

sub new {
  my ($class, $filename, $base_data, $current_data, $linemap, $verbose) = @_;

  my $self = {};  # hash of lineNumber -> LineData struct
  bless $self, $class;

  $linemap->show_map($filename)
    if (( defined($verbose) && $verbose) ||
        (defined($lcovutil::verbose) && $lcovutil::verbose));

  # line coverage categorization includes date- and owner- bins in
  #   the vanilla case when there is no baseline.
  $self->_categorizeLineCov($filename, $base_data, $current_data,
                            $linemap, $verbose);
  $self->_categorizeBranchCov($filename, $base_data, $current_data,
                              $linemap, $verbose)
    if ($main::br_coverage);
  return $self;
}

sub line {
  my ($self, $lineNo) = @_;

  return exists($self->{$lineNo}) ? $self->{$lineNo} : undef;
}

# categorize line coverage numbers
sub _categorizeLineCov {
  my ($self, $filename, $base_data, $current_data, $linemap, $verbose) = @_;

  my $lineCovBase = $base_data->data($filename)->test();
  my $lineCovCurrent = $current_data->data($filename)->test();

  foreach my $testcase ($lineCovCurrent->keylist()) {
    my $testcount = $lineCovCurrent->value($testcase);
    foreach my $line ($testcount->keylist()) {
      my $type = $linemap->type($filename, "new", $line);
      if ($type ne "delete") {
        if (!defined($self->{$line})) {
          $self->{$line} = LineData->new($type);
        }
        my $val = $testcount->value($line);
        my $linedata = $self->{$line};
        $linedata->lineNo("current", $line);
        $linedata->curr_count($val);
      }
    }
  }
  foreach my $testcase ($lineCovBase->keylist()) {
    my $testcount = $lineCovBase->value($testcase);
    foreach my $bline ($testcount->keylist()) {
      my $cline =  $linemap->lookup($filename, "old", $bline);
      my $type = $linemap->type($filename, "old", $bline);
      my $linedata;
      if ($type ne "delete") {
        if (!defined($self->{$cline})) {
          $self->{$cline} = LineData->new($type);
        }
        $linedata = $self->{$cline};
      } else {
        # nothing walks the keylist so a prefix is sufficient to distiguish
        # records that should be summarized but not displayed
        my $dline = "<<<".$bline;
        if (!defined($self->{$dline})) {
          $self->{$dline} = LineData->new($type);
        }
        $linedata = $self->{$dline};
      }
      my $val = $testcount->value($bline);
      $linedata->lineNo("base", $bline);
      $linedata->base_count($val);
    }
  }

  foreach my $line (keys %$self) {
    my $linedata = $self->{$line};
    if ($linedata->type() eq "insert") {
      if ($linedata->curr_count() > 0) {
        $linedata->tla("GNC");
      } elsif ($linedata->curr_count() == 0) {
        $linedata->tla("UNC");
      } else {
        warn "LineCoverageInfo:: negative count for insert line=$line file=$filename\n";
      }
    } elsif ($linedata->type() eq "delete") {
      if ($linedata->base_count() > 0) {
        $linedata->tla("DCB");
      } elsif ($linedata->base_count() == 0) {
        $linedata->tla("DUB");
      } else {
        warn "LineCoverageInfo:: negative count for delete line=$line file=$filename\n";
      }
    } elsif ($linedata->type() eq "equal") {
      if ($linedata->in_base() && $linedata->in_curr()) {
        if ($linedata->base_count() > 0 &&
            $linedata->curr_count() > 0) {
          $linedata->tla("CBC");
        } elsif ($linedata->base_count() == 0 &&
                 $linedata->curr_count() > 0) {
          $linedata->tla("GBC");
        } elsif ($linedata->base_count() > 0 &&
                 $linedata->curr_count() == 0) {
          $linedata->tla("LBC");
        } elsif ($linedata->base_count() == 0 &&
                 $linedata->curr_count() == 0) {
          $linedata->tla("UBC");
        } else {
          my $basecnt = $linedata->base_count();
          my $currcnt = $linedata->curr_count();
          my $type = $linedata->type();
          lcovutil::info("        UNK:base/curr line=$line type=$type base=$basecnt curr=$currcnt file=$filename\n");
        }
      } elsif ($linedata->in_base()) {
        if ($linedata->base_count() > 0) {
          $linedata->tla("ECB");
        } elsif ($linedata->base_count() == 0) {
          $linedata->tla("EUB");
        } else {
          my $basecnt = $linedata->base_count();
          my $currcnt = $linedata->curr_count();
          my $type = $linedata->type();
          lcovutil::info("        UNK:base line=$line type=$type base=$basecnt curr=$currcnt file=$filename\n");
        }
      } elsif ($linedata->in_curr()) {
        if ($linedata->curr_count() > 0) {
          $linedata->tla("GIC");
        } elsif ($linedata->curr_count() == 0) {
          $linedata->tla("UIC");
        } else {
          my $basecnt = $linedata->base_count();
          my $currcnt = $linedata->curr_count();
          my $type = $linedata->{type};
          lcovutil::info("        UNK:curr line=$line type=$type base=$basecnt curr=$currcnt file=$filename\n");
        }
      } else {
        warn "LineCoverageInfo:: non-executed line line=$line file=$filename\n";
      }
    } else {
      warn "LineCoverageInfo:: deleted segment line=$line file=$filename\n";
    }
  }
}


# categorize branch coverage numbers
sub _categorizeBranchCov {
  my ($self, $filename, $base_data, $current_data, $linemap, $verbose) = @_;

  my $branchCovBase = $base_data->data($filename)->testbr();
  my $branchCovCurrent = $current_data->data($filename)->testbr();

  my %branchCovLines;
  # look through the 'current' data, to find all the branch data
  foreach my $testcase ($branchCovCurrent->keylist()) {
    my $branchCurrent = $branchCovCurrent->value($testcase);
    foreach my $line ($branchCurrent->keylist()) {
      my $type = $linemap->type($filename, "new", $line);
      next if $type eq 'delete';

      $branchCovLines{$line} = 1;
      my $data;
      if (! exists($self->{$line})) {
        $data = LineData->new($type);
        $self->{$line} = $data;
        # we expect the associated line to also have line coverage data
        lcovutil::ignorable_error($ERROR_UNKNOWN_CATEGORY,
                        "line $line of $filename has branchcov but no linecov data");
      } else {
        $data = $self->{$line};
      }
      # we expect that the line number matches...
      $data->lineNo("current", $line);
      # append this branch data for the line
      my $currBranchData = $branchCurrent->value($line);
      $data->current_branch($currBranchData);
    } # foreach line in this testcase's branch data
  } #foreach current testcase

  # now look through the baseline to find matching data
  foreach my $testcase ($branchCovBase->keylist()) {
    my $branchBaseline = $branchCovBase->value($testcase);
    foreach my $base_line ($branchBaseline->keylist()) {
      my $curr_line = $linemap->lookup($filename, "old", $base_line);
      my $type = $linemap->type($filename, "old", $base_line);
      my $data;
      if ($type ne 'delete') {
        $branchCovLines{$curr_line} = 1;
        if (! exists($self->{$curr_line}) ) {
          $data = LineData->new($type);
          $self->{$curr_line} = $data;
        } else {
          $data = $self->{$curr_line};
        }
      } else {
        # the line has been deleted...just record the data
        my $deleteKey = "<<<" . $ base_line;
        $branchCovLines{$deleteKey} = 1;
        if (! exists($self->{$deleteKey}) ) {
          $data = LineData->new($type);
          $self->{$deleteKey} = $data;
        } else {
          $data = $self->{$deleteKey};
        }
      }
      $data->lineNo("base", $base_line);
      my $baseBranchData = $branchBaseline->value($base_line);
      $data->baseline_branch($baseBranchData);
    } # foreach line in baseline data for this test..
  } # foreach baseline testcase

  # now go through all the branch data for each line, and categorize everything
  foreach my $line (keys(%branchCovLines)) {
    my $data = $self->{$line};
    my $type = $data->type();
    my $curr = $data->current_branch();
    my $base = $data->baseline_branch();
    my $categorized = BranchEntry->new($line);
    $data->differential_branch($categorized);
    # handle case that baseline and/or current do not contain branch data
    my @currBlocks = defined($curr) ? $curr->blocks() : ();
    my @baseBlocks = defined($base) ? $base->blocks() : ();

    if ($type eq 'insert') {
      ! defined($base) or die("baseline branch data should not be defined for inserted line $line");
      foreach my $branchId (@currBlocks) {
        my $block = $categorized->addBlock($branchId);
        foreach my $taken (@{$curr->getBlock($branchId)}) {
          my $tla = ('-' eq $taken || 0 == $taken) ? 'UNC': 'GNC';
          push(@$block, [$taken, $tla]);
        }
      }
    } elsif ($type eq 'delete') {
      ! defined($curr) or die("current branch data should not be defined for deleted line");
      foreach my $branchId (@baseBlocks) {
        my $block = $categorized->addBlock($branchId);
        foreach my $taken (@{$base->getBlock($branchId)}) {
          my $tla = ('-' eq $taken || 0 == $taken) ? 'DCB': 'DUB';
          push(@$block, [$taken, $tla]);
        }
      }
    } else {
      $type eq 'equal' or die("unexpected branch coverage type $type");

      # branch might or might not be in both baseline and current
      foreach my $branchId (@baseBlocks) {
        my $b = $base->getBlock($branchId);
        my $branchData = $categorized->addBlock($branchId);
        if (defined($curr) &&
            $curr->hasBlock($branchId)) {
          my $c = $curr->getBlock($branchId);

          my $num_base = scalar(@$b);
          my $num_curr = scalar(@$c);
          my $max = $num_base > $num_curr ? $num_base : $num_curr;
          my $tla;
          for (my $i=0 ; $i < $max ; ++ $i) {
            if ( $i < $num_base &&
                 $i < $num_curr) {
              my $base_taken = $b->[$i];
              my $curr_taken = $c->[$i];
              if ('-' eq $base_taken ||
                  0 == $base_taken) {
                $tla = ($curr_taken eq '-' || 0 == $curr_taken) ? 'UBC' : 'GBC';
              } elsif ($curr_taken eq '-' || 0 == $curr_taken) {
                $tla = 'LBC';
              } else {
                $tla = 'CBC';
              }
              push(@$branchData, [$curr_taken, $tla]);
            } elsif ($i < $num_base) {
              my $base_taken = $b->[$i];
              $tla = ('-' eq $base_taken || 0 == $base_taken) ? 'EUB' : 'ECB';
              push(@$branchData, [$base_taken, $tla]);
            } else {
              my $curr_taken = $c->[$i];
              $tla = ('-' eq $curr_taken || 0 == $curr_taken) ? 'UIC' : 'GIC';
              push(@$branchData, [$curr_taken, $tla]);
            }
          }
        } else {
          # branch not found in current...
          foreach my $base_taken (@$b) {
            my $tla = ('-' eq $base_taken || 0 == $base_taken) ? 'EUB' : 'ECB';
            push(@$branchData, [$base_taken, $tla]);
          }
        }
      }
      # now check for branches that are in current but not in baseline...
      foreach my $branchId (@currBlocks) {
        next if defined($base) && $base->hasBlock($branchId); # already processed
        my $c = $curr->getBlock($branchId);
        my $branchData = $categorized->addBlock($branchId);
        foreach my $curr_taken (@$c) {
          my $tla = ('-' eq $curr_taken || 0 == $curr_taken) ? 'UIC' : 'GIC';
          push(@$branchData, [$curr_taken, $tla]);
        }
      } # foreach branchId in current that isn't in base
    }
  }
}

package LineMap;
sub new {
  my $class = shift;
  my $self = {};
  bless $self, $class;
  $self->{hunks} = [ ];
  $self->{linemap} = { };
  $self->{filemap} = { };
  return $self;
}

sub load {
  my $self = shift;
  my $path = shift;
  $self->_read_udiff($path);

  return $self;
}

sub lookup {
  my $self = shift;
  my $file = shift;
  my $vers = shift;
  my $line = shift;

  if (!defined($self->{linemap}->{$file})) {
    #mapping is identity when no diff was read
    return $line;
  }

  my @candidates = grep { $_->{$vers}->{start} < $line } @{$self->{linemap}->{$file}};
  my $chunk = pop @candidates;

  my $alt = ($vers eq "old") ? "new" : "old";

  if ($line > $chunk->{$vers}->{end}) {
    return ($chunk->{$alt}->{end} + ($line - $chunk->{$vers}->{end}));
  }
  return ($chunk->{$alt}->{start} + ($line - $chunk->{$vers}->{start}));
}

sub type {
  my $self = shift;
  my $file = shift;
  my $vers = shift;
  my $line = shift;

  if (!defined($self->{linemap}->{$file})) {
    #mapping is identity when no diff was read
    if (defined($main::show_tla)) {
      return "equal"; # categories will be "GIC", "UIC"
    } else {
      return "insert"; # categories will be "GNC", "UNC"
    }
  }

  if (!defined($self->{filemap}->{$file})) {
    #mapping with no filemap when baseline file was deleted
    return "delete"
  }

  # ->{start} equal $line only if beginning of range or omitted in ->{type}
  my @candidates = grep { $_->{$vers}->{start} <= $line } @{$self->{linemap}->{$file}};
  my $chunk = pop @candidates;
  my $prev = pop @candidates;
  while (defined($prev) &&
         $line >= $prev->{$vers}->{start} &&
         $line <= $prev->{$vers}->{end}) {
    $chunk = $prev;
    $prev = pop @candidates
  }
  if (!defined($chunk)) {
    warn "LineMap::type(): got undef chunk at $file, $vers, $line\n";
    return "undef chunk";
  }
  if (!defined($chunk->{type})) {
    warn "LineMap::type(): got undef type at $file, $vers, $line\n";
    return "undef type";
  }
  return $chunk->{type};
}


sub dump_map {
  my $self = shift;

  foreach my $file (keys %{$self->{filemap}}) {
    my $currfile = defined($self->{filemap}->{$file}) ? $self->{filemap}->{$file} : "[deleted]";
    printf("In $file (was: $currfile):\n");
    foreach my $chunk (@{$self->{linemap}->{$file}}) {
      printf("  %6s\t[%d:%d]\t[%d:%d]\n",
             $chunk->{type},
             $chunk->{old}->{start},
             $chunk->{old}->{end},
             $chunk->{new}->{start},
             $chunk->{new}->{end});
    }
  }
  return $self;
}


sub show_map {
  my $self = shift;
  my $file = shift;

  if (!defined($self->{filemap}->{$file})) {
    return $self;
  }
  my $currfile = defined($self->{filemap}->{$file}) ? $self->{filemap}->{$file} : "[deleted]";
  printf("In $file (was: $currfile):\n");
  foreach my $chunk (@{$self->{linemap}->{$file}}) {
      printf("  %6s\t[%d:%d]\t[%d:%d]\n",
             $chunk->{type},
             $chunk->{old}->{start},
             $chunk->{old}->{end},
             $chunk->{new}->{start},
             $chunk->{new}->{end});
  }
  return $self;
}


sub strip_directories {
  my $path = shift;
  return $path;
}

sub _read_udiff {
  my $self = shift;
  my $diff_file = shift;        # Name of diff file
  my $line;             # Contents of current line
  my $file_old;         # Name of old file in diff section
  my $file_new;         # Name of new file in diff section
  my $filename;         # Name of common filename of diff section
  local *HANDLE;                # File handle for reading the diff file

  # Check if file exists and is readable
  stat($diff_file);
  if (!(-r _)) {
    die("ERROR: cannot read file $diff_file!\n");
  }

  ## Check if this is really a plain file
  #if (!(-f _)) {
  #  die("ERROR: not a plain file: $diff_file!\n");
  #}

  ## Check for .gz extension
  #if ($diff_file =~ /\.gz$/) {
  #  # Check for availability of GZIP tool
  #  lcovutil::system_no_output(1, "gunzip", "-h")
  #    and die("ERROR: gunzip command not available!\n");

  #  # Check integrity of compressed file
  #  lcovutil::system_no_output(1, "gunzip", "-t", $diff_file)
  #    and die("ERROR: integrity check failed for ".
  #           "compressed file $diff_file!\n");

  #  # Open compressed file
  #  open(HANDLE, "-|", "gunzip -c '$diff_file'")
  #    or die("ERROR: cannot start gunzip to decompress ".
  #          "file $_[0]!\n");
  #} else {
    # Open decompressed file
    open(HANDLE, "<", $diff_file)
      or die("ERROR: cannot read file $diff_file!\n");
  #}

  my $chunk;
  my $old_block = 0;
  my $new_block = 0;
  # Parse diff file line by line
  while (<HANDLE>) {
    chomp($_);
    $line = $_;

    foreach ($line) {
      # Filename of old file:
      # --- <filename> <date>
      /^--- (\S+)/ && do
        {
          if ($filename) {
            push(@{$self->{linemap}->{$filename}}, $chunk);
          }
          $file_old = main::strip_directories($1, $main::strip);
          #$in_block = 0;
          last;
        };
      # Filename of new file:
      # +++ <filename> <date>
      /^\+\+\+ (\S+)/ && do
        {
          # Add last file to resulting hash
          $file_new = main::strip_directories($1, $main::strip);
          $filename = ($file_new ne "/dev/null") ? $file_new : undef;
          if ($filename) {
            $self->{linemap}->{$filename} = [ ];
          }
          if ($file_new ne "/dev/null") {
            $self->{filemap}->{$file_new} = $file_old;
          }

          $chunk = { };
          $chunk->{from} = { };
          $chunk->{to} = { };
          $chunk->{type} = "equal";
          $chunk->{old}->{start} = 1;
          $chunk->{old}->{end} = 1;
          $chunk->{new}->{start} = 1;
          $chunk->{new}->{end} = 1;

          last;
        };
      # Start of diff block:
      # @@ -old_start,old_num, +new_start,new_num @@
      /^\@\@\s+-(\d+),(\d+)\s+\+(\d+),(\d+)\s+\@\@.*$/ && do
        {
          if ($1 > ($chunk->{old}->{end})) {
            # old start skips "equal" lines
            if ($chunk->{type} ne "equal") {
              if ($filename) {
                push(@{$self->{linemap}->{$filename}}, $chunk);
              }
              my $oldchunk = $chunk;
              $chunk = { };
              $chunk->{from} = { };
              $chunk->{to} = { };
              $chunk->{type} = "equal";
              $chunk->{old}->{start} = $oldchunk->{old}->{end} + 1;
              $chunk->{old}->{end} = $oldchunk->{old}->{end} + 1;
              $chunk->{new}->{start} = $oldchunk->{new}->{end} + 1;
              $chunk->{new}->{end} = $oldchunk->{new}->{end} + 1;
            }
            $chunk->{type} = "equal";
            $chunk->{old}->{end} = $1 - 1;  # will increment on content lines
            $chunk->{new}->{end} = $3 - 1;
          } else {
            $chunk->{old}->{end} = $1 - 1;  # will increment on content lines
            $chunk->{new}->{end} = $3 - 1;
          }
          $old_block = $2;
          $new_block = $4;
          #printf "equal [%d:%d] [%d:%d]\n", $l[0], $l[1], $l[2], $l[3];
          last;
        };
      # Unchanged line
      # <line starts with blank>
      /^ / && do
        {
          if ($old_block == 0 && $new_block == 0) {
            last;
          }
          if ($chunk->{type} ne "equal") {
            if ($filename) {
              push(@{$self->{linemap}->{$filename}}, $chunk);
            }
            my $oldchunk = $chunk;
            $chunk = { };
            $chunk->{from} = { };
            $chunk->{to} = { };
            $chunk->{type} = "equal";
            $chunk->{old}->{start} = $oldchunk->{old}->{end} + 1;
            $chunk->{old}->{end} = $oldchunk->{old}->{end} + 1;
            $chunk->{new}->{start} = $oldchunk->{new}->{end} + 1;
            $chunk->{new}->{end} = $oldchunk->{new}->{end} + 1;
          } else {
            $chunk->{new}->{end} += 1;
            $chunk->{old}->{end} += 1;
          }
          last;
        };
      # Line as seen in old file
      # <line starts with '-'>
      /^-/ && do
        {
          if ($old_block == 0 && $new_block == 0) {
            last;
          }
          if ($chunk->{type} ne "delete") {
            if ($filename) {
              push(@{$self->{linemap}->{$filename}}, $chunk);
            }
            my $oldchunk = $chunk;
            $chunk = { };
            $chunk->{from} = { };
            $chunk->{to} = { };
            $chunk->{type} = "delete";
            $chunk->{old}->{start} = $oldchunk->{old}->{end} + 1;
            $chunk->{old}->{end} = $oldchunk->{old}->{end} + 1;
            $chunk->{new}->{start} = $oldchunk->{new}->{end};
            $chunk->{new}->{end} = $oldchunk->{new}->{end};
          } else {
            #$chunk->{old}->{start} += 1;
            $chunk->{old}->{end} += 1;
          }
          last;
        };
      # Line as seen in new file
      # <line starts with '+'>
      /^\+/ && do
        {
          if ($old_block == 0 && $new_block == 0) {
            last;
          }
          if ($chunk->{type} ne "insert") {
            if ($filename) {
              push(@{$self->{linemap}->{$filename}}, $chunk);
            }
            my $oldchunk = $chunk;
            $chunk = { };
            $chunk->{from} = { };
            $chunk->{to} = { };
            $chunk->{type} = "insert";
            $chunk->{old}->{start} = $oldchunk->{old}->{end};
            $chunk->{old}->{end} = $oldchunk->{old}->{end};
            $chunk->{new}->{start} = $oldchunk->{new}->{end} + 1;
            $chunk->{new}->{end} = $oldchunk->{new}->{end} + 1;
          } else {
            #$chunk->{new}->{start} += 1;
            $chunk->{new}->{end} += 1;
          }
          last;
        };
      # Empty line
      /^$/ && do
        {
          if ($old_block == 0 && $new_block == 0) {
            last;
          }
          if ($chunk->{type} ne "equal") {
            if ($filename) {
              push(@{$self->{linemap}->{$filename}}, $chunk);
            }
            my $oldchunk = $chunk;
            $chunk = { };
            $chunk->{from} = { };
            $chunk->{to} = { };
            $chunk->{type} = "equal";
            $chunk->{old}->{start} = $oldchunk->{old}->{end} + 1;
            $chunk->{old}->{end} = $oldchunk->{old}->{end} + 1;
            $chunk->{new}->{start} = $oldchunk->{new}->{end} + 1;
            $chunk->{new}->{end} = $oldchunk->{new}->{end} + 1;
          } else {
            $chunk->{new}->{end} += 1;
            $chunk->{old}->{end} += 1;
          }
          last;
        };
    }
  }

  close(HANDLE);

  # Add final diff file section to resulting hash
  if ($filename) {
    push(@{$self->{linemap}->{$filename}}, $chunk);
  }

  if (scalar(keys %{$self->{linemap}}) == 0) {
    warn("ERROR: no valid diff data found in $diff_file!\n".
        "Make sure to use 'diff -u' when generating the diff ".
        "file.\n");
  }
  return $self;
}


package SourceLine;

sub new {
  my $class = shift;
  my @data = @_; #[owner, age, line, text, lineCovTla]
  my $self = \@data;
  bless $self, $class;
  $self->[4] = undef
    if scalar(@$self) < 5; # set TLA
  $self->[5] = undef
    if scalar(@$self) < 6; # set branch data
  return $self;
}

sub owner {
  my $self = shift;
  return $self->[0];
}

# line coverage TLA
sub tla {
  my ($self, $tla) = @_;
  $self->[4] = $tla
      if (defined($tla));
  return $self->[4];
}

sub branchElem {
  my ($self, $branchElem) = @_;
  $self->[5] = $branchElem
    if defined($branchElem);
  return $self->[5];
}

sub age {
  my $self = shift;
  return $self->[1];
}

sub line {
  my $self = shift;
  return $self->[2];
}

sub text {
  my $self = shift;
  return $self->[3];
}

package SourceFile;
our $annotateScript;

sub new {
  # countdata may be 'undef'
  my ($class, $filepath, $fileSummary, $lineCovInfo, $countdata) = @_;

  (ref($fileSummary) eq 'SummaryInfo' && ref($lineCovInfo) eq "LineCoverageInfo")
    or die("unexpected input args");

  my $self = {};
  bless $self, $class;

  $self->{_path} = $filepath;
  $self->{_lines} = [ ]; #line coverage data for line
  $self->{_owners} = {}; # owner -> hash of TLA->list of lines
  $self->{_categories} = {}; # TLA -> list of lines

  $self->{_owners_branch} = {}; # owner -> hash of TLA->list of lines

  # use the line coverage count to synthesize a fake file, if we can't
  #   find an actual file
  $self->_load($countdata);

  if (defined($main::show_dateBins) &&
      $self->notProjectFile()) {
    lcovutil::info("no owner/date info for '$filepath'\n");
  }

  # sort lines in ascending numerical order - we want the 'owner'
  #   and 'tla' line lists to be sorted - and it is probably faster to
  #   sort the file list once than to sort each of the sub-lists
  #   individually afterward.
  # DCB, DUB category keys have leading "<<<" characters - which we strip
  #  in order to compare
  my $currentTla;
  my $regionStartLine;
  foreach my $line
    (sort( { my $ka = ("<" ne substr($a,0,1)) ? $a : substr($a,3);
             my $kb = ("<" ne substr($b,0,1)) ? $b : substr($b,3);
             $ka <=> $kb } keys(%{$lineCovInfo}))) {
    my $lne = $lineCovInfo->{$line};
    $self->_countLineTlaData($line, $lne, $fileSummary);

    $self->_countBranchTlaData($line, $lne, $fileSummary)
      if (defined($lne->differential_branch()));
  }
  return $self;
}


sub _countBranchTlaData {
  my ($self, $line, $lineData, $fileSummary) = @_;
  my $differentialData = $lineData->differential_branch();

  my %foundBranchTlas;
  my ($src_age, $developer);
  my $srcLine = $self->line($line);
  if (! defined($srcLine)) {
    lcovutil::ignorable_error($ERROR_UNMAPPED_LINE,
                              "no data for 'branch' line:$line, file:"
                              . $self->path())
  } else {
    # if this line is not in the project (e.g., from some 3rd party
    #   library - then we might not have file history for it.
    $src_age = $srcLine->age();
    $developer = $srcLine->owner();
    $srcLine->branchElem($differentialData);

    if (defined($developer)) {
      my $shash = $self->{_owners_branch};
      if (! exists($shash->{$developer})) {
        $shash->{$developer} = {};
        $shash->{$developer}->{lines} = [];
      }
      push(@{$shash->{$developer}->{lines}}, $line);
    }
  }

  my %recorded;
  foreach my $branchId ($differentialData->blocks()) {
    my $diff = $differentialData->getBlock($branchId);
    foreach my $b (@$diff) {
      my $tla = $b->[1];
      $fileSummary->{branch}->{$tla} += 1;
      # keep track of all the branch TLAs found on this line...
      if (! exists($foundBranchTlas{$tla})) {
        $foundBranchTlas{$tla} = 1;
        $self->{_categories_branch}->{$tla} = []
          unless exists($self->{_categories_branch}->{$tla});
        push(@{$self->{_categories_branch}->{$tla}}, $line);
      }

      next
        if (0 == ($SummaryInfo::tlaLocation{$tla} & 0x1));
        # skip "DUB' and 'DCB' categories - which are not in current
        #   and thus have no line associated

      # and the age...
      #lcovutil::info("$l: $tla" . $lineData->in_curr() . "\n");

      next unless defined($srcLine) && defined($src_age);

      # increment count of branches of this age we found for this TLA
      $fileSummary->branchCovCount($tla, "age", $src_age, 1);

      # HGC:  could clean this up...no need to keep track
      #   of 'hit' as we can just compute from CBC + GNC + ...
      # found another line...
      my $hit = ($tla eq 'GBC' ||
                 $tla eq 'GIC' ||
                 $tla eq 'GNC' ||
                 $tla eq 'CBC');
      $fileSummary->branchCovCount("found", "age", $src_age, 1);
      $fileSummary->branchCovCount("hit", "age", $src_age, 1)
        if $hit;

      next
        unless defined($developer);

      # add this line to those that belong to this owner..

      # first:  increment line count in 'file summary'
      my $ohash = $fileSummary->{owners_branch};
      if (! exists($ohash->{$developer})) {
        my %data = ('hit' => $hit ? 1 : 0,
                    'found' => 1,
                    $tla => 1);
        $ohash->{$developer} = \%data;
      } else {
        my $d = $ohash->{$developer};
        $d->{$tla} = 0
            unless exists($d->{$tla});
        $d->{$tla} += 1;
        $d->{found} += 1;
        $d->{hit} += 1
          if $hit;
      }

      # now append this branchTLA to the owner...
      my $ownerKey = $developer . $tla;
      if (! exists($recorded{$ownerKey})) {
        $recorded{$ownerKey} = 1;
        my $dhash = $self->{_owners_branch}->{$developer};
        $dhash->{$tla} = []
          unless exists($dhash->{$tla});
        push(@{$dhash->{$tla}}, $line);
      }
    }
  }
}

sub _countLineTlaData {
  my ($self, $line, $lineData, $fileSummary) = @_;
  # there is differential line coverage data...
  my $tla = $lineData->tla();

  if (! exists($SummaryInfo::tlaLocation{$tla})) {
    # this case can happen if the line number annotations are
    #   wrong in the .info file - so the branch coverage line
    #   number turns out not to be an executable source code line
    lcovutil::ignorable_error($ERROR_UNKNOWN_CATEGORY,
                    "unexpected category $tla for line "
                    . $self->path() . ":$line");
    return;
  }
  # one more line in this bucket...
  $fileSummary->{line}->{$tla} += 1;
  # create the category list, if necessary
  $self->{_categories}->{$tla} = []
    unless exists($self->{_categories}->{$tla});

  push(@{$self->{_categories}->{$tla}}, $line);

  # and the age data...

  if ($SummaryInfo::tlaLocation{$tla} & 0x1) {
    # skip "DUB' and 'DCB' categories - which are not in current
    #   and thus have no line associated

    #lcovutil::info("$l: $tla" . $lineData->in_curr() . "\n");

    my $l = $self->line($line);

    if (! defined($l)) {
      lcovutil::ignorable_error($ERROR_UNMAPPED_LINE,
                      "no data for line:$line, TLA:$tla, file:" .
                      $self->path());
      return;
    }
    # set the TLA of this line...
    $l->tla($tla);

    my $src_age = $l->age();
    # if this line is not in the project (e.g., from some 3rd party
        #   library - then we might not have file history for it.
    return
      unless defined($src_age);

    # increment count of lines of this age we found for this TLA
    $fileSummary->lineCovCount($tla, "age", $src_age, 1);

    if ($lineData->in_curr()) {
      # HGC:  could clean this up...no need to keep track
      #   of 'hit' as we can just compute from CBC + GNC + ...
      # found another line...
      $fileSummary->lineCovCount("found", "age", $src_age, 1);
      if ($lineData->curr_count() > 0) {
        $fileSummary->lineCovCount("hit", "age", $src_age, 1);
      }
    }

    if (defined($l->owner())) {
      # add this line to those that belong to this owner..
      my $developer = $l->owner();

      # first:  increment line count in 'file summary'
      my $ohash = $fileSummary->{owners};
      $ohash->{$developer} = {}
        unless exists($ohash->{$developer});
      my $d = $ohash->{$developer};
      $d->{$tla} = 0
        unless exists($d->{$tla});
      $d->{$tla} += 1;

      # now push this line onto the list of in this file, belonging
      #   to this owner
      $self->{_owners}->{$developer} = {}
        unless exists($self->{_owners}->{$developer});
      my $dhash = $self->{_owners}->{$developer};
      $dhash->{lines} = []
        unless exists($dhash->{lines});
      push(@{$dhash->{lines}}, $line);
      $dhash->{$tla} = []
        unless exists($dhash->{$tla});
      # and the list of lines with this TLA, belowing to this user
      push(@{$dhash->{$tla}}, $line);
    }
  }
}

sub path {
  my $self = shift;
  return $self->{_path};
}

sub notProjectFile {
    # return 'true' if no owner/date information for this file.
    my $self = shift;
    return ! scalar(%{$self->{_owners}});
}

sub isProjectFile {
    # return 'true' if no owner/date information for this file.
    my $self = shift;
    return scalar(%{$self->{_owners}});
}

sub line {
  my $self = shift;
  my $i = shift;
  return ${$self->{_lines}}[$i - 1];
}

sub lines {
  my $self = shift;
  return $self->{_lines};
}

sub binarySearchLine {
  my ($list, $after) = @_;

  defined($list) && 0 != scalar(@$list)
    or die("invalid location list");

  my $max = $#$list;
  my $min = 0;
  my $mid;
  while (1) {
    $mid = int(($max + $min)/2);
    my $v = $list->[$mid];
    if ($v > $after) {
      $max = $mid;
    } elsif ($v < $after) {
      $min = $mid;
    } else {
      return $mid;
    }
    my $diff = $max - $min;
    if ($diff <= 1) {
      $mid = $min;
      $mid = $max
        if $list->[$min] < $after;
      last;
    }
  }
  return $list->[$mid] >= $after ? $mid : undef;
}

sub nextTlaGroup {
    # return number of first line of next group of specified linecov TLA -
    #  for example, if line [5:8] and [13:17] are 'CNC', then:
    #     5 = nextTlaGroup('CBC')     : "after == undef"
    #    13 = nextTlaGroup('CBC', 5)  : skip contiguous group of CBC lines
    #  undef = nexTlaGroup('CBC', 13) : no following group
    my ($self, $tla, $after) = @_;
    die("unknown TLA '$tla'")
        unless exists($SummaryInfo::tlaLocation{$tla});

    # note the the "$self->line(...)" argument is 1-based (not zero-base)
    my $line;
    if (defined($after)) {
        die("$after is not in $tla group")
            unless ( $self->line($after)->tla() eq $tla );
        # skip to the end of the current section...
        # if the TLA of this group is unset (non-code line: comment,
        #   blank, etc) - then look for next code line.  If that line's
        #   TLA matches, then treat as a contiguous group.
        # This way, we avoid visual clutter from having a lot of single-line
        #   TLA segments.
        my $lastline = scalar(@{$self->{_lines}});
        for ($line = $after + 1 ; $line <= $lastline ; ++ $line) {
            my $t = $self->line($line)->tla();
            last
                if (defined($t) &&
                    $t ne $tla);
        }
    } else {
        $line = 1;
    }
    my $locations = $self->{_categories}->{$tla};
    my $idx = binarySearchLine($locations, $line);
    return defined($idx) ? $locations->[$idx] : undef;
}

sub nextBranchTlaGroup {
  # return number of first line of next group of specified branchcov TLA -
  # note that all branch lines are independent - so we will
  # report and go the next branch, even if it is on the adjacent line
  my ($self, $tla, $after) = @_;
  die("unknown TLA '$tla'")
    unless exists($SummaryInfo::tlaLocation{$tla});
  die("no branch data for TLA '$tla'")
    unless exists($self->{_categories_branch}->{$tla});

  my $locations = $self->{_categories_branch}->{$tla};

  $after = defined($after) ? $after + 1 : 1;
  my $idx = binarySearchLine($locations, $after);
  return defined($idx) ? $locations->[$idx] : undef;
}

sub nextInDateBin {
  my ($self, $dateBin, $tla, $after) = @_;

  exists($SummaryInfo::tlaLocation{$tla})
    or die("unknown TLA '$tla'");
  $dateBin <= $#SummaryInfo::ageGroupHeader
    or die("unexpected age group $dateBin");

  # note the the "$self->line(...)" argument is 1-based (not zero-base)
  my $line;
  if (defined($after)) {

    ( $self->line($after)->tla() eq $tla )
      or die("$after is not in $tla group");

    my $lastline = scalar(@{$self->{_lines}});
    # skip to the end of the current section...
    for ($line = $after + 1 ; $line <= $lastline ; ++ $line) {
      my $t = $self->line($line)->tla();
      my $a = $self->line($line)->age();
      last
        if (defined($t) &&
            ($t ne $tla ||
             $dateBin != SummaryInfo::findAgeBin($a)));
    }
  } else {
      $line = 1;
  }
  # the data isn't stored by date bin (at least for now) - so the
  #   only way to find it currently is by searching forward.
  my $tlaLocations = $self->{_categories}->{$tla};
  my $idx = binarySearchLine($tlaLocations, $line);
  return undef unless defined($idx);
  my $max = scalar(@$tlaLocations);
  for ( ; $idx < $max ; ++ $idx) {
    $line = $tlaLocations->[$idx];
    my $l = $self->line($line);
    if (! defined($l)) {
      lcovutil::ignorable_error($ERROR_UNMAPPED_LINE,
                                "no data for line:$line, file:"
                                . $self->path());
        next;
    }
    my $a = $l->age();
    my $bin = SummaryInfo::findAgeBin($a);

    if ($bin == $dateBin) {
      my $t = $l->tla();
      return $line
        if (defined($t) &&
            $t eq $tla);
    }
  }
  return undef;
}

sub nextInOwnerBin {
  my ($self, $owner, $tla, $after) = @_;

  exists($SummaryInfo::tlaLocation{$tla})
    or die("unknown TLA '$tla'");
  exists($self->{_owners}->{$owner}) && exists($self->{_owners}->{$owner}->{$tla})
    or die("$owner not responsible for any $tla lines in" . $self->path());

  # note the the "$self->line(...)" argument is 1-based (not zero-base)
  my $line;
  if (defined($after)) {

    ( $self->line($after)->tla() eq $tla )
      or die("$after is not in $tla group");

    my $lastline = scalar(@{$self->{_lines}});
    # skip to the end of the current section...
    for ($line = $after + 1 ; $line <= $lastline ; ++ $line) {
      my $l = $self->line($line);
      if (! defined($l)) {
        lcovutil::ignorable_error($ERROR_UNMAPPED_LINE,
                                  "no data for line:$line, file:"
                                  . $self->path());
        next;
      }
      my $t = $l->tla();
      my $o = $l->owner();
      last
        if (defined($t) &&
            ($t ne $tla ||
             $o ne $owner));
    }
  } else {
    $line = 1;
  }

  my $locations = $self->{_owners}->{$owner}->{$tla};
  my $idx = binarySearchLine($locations, $line);
  return defined($idx) ? $locations->[$idx] : undef;
}

sub nextBranchInDateBin {
  my ($self, $dateBin, $tla, $after) = @_;

  exists($SummaryInfo::tlaLocation{$tla})
    or die("unknown TLA '$tla'");
  $dateBin <= $#SummaryInfo::ageGroupHeader
    or die("unexpected age group $dateBin");

  # note the the "$self->line(...)" argument is 1-based (not zero-base)
  $after = defined($after) ? $after + 1 : 1;

  exists($self->{_categories_branch}->{$tla})
    or die("no $tla branches in " . $self->path());

  my $lines = $self->{_categories_branch}->{$tla};
  my $idx = binarySearchLine($lines, $after);

  return undef unless defined($idx);
  my $max = scalar(@$lines);
  for ( ; $idx < $max ; ++ $idx) {
    my $line = $lines->[$idx];
    my $l = $self->line($line);
    if (! defined($l)) {
      lcovutil::ignorable_error($ERROR_UNMAPPED_LINE,
                                "no data for line:$line, file:"
                                . $self->path());
      next;
    }
    my $a = $l->age();
    my $bin = SummaryInfo::findAgeBin($a);
    if ($bin == $dateBin) {
      return $line;
    }
  }
  return undef;
}

sub nextBranchInOwnerBin {
  my ($self, $owner, $tla, $after) = @_;

  exists($SummaryInfo::tlaLocation{$tla})
    or die("unknown TLA '$tla'");

  # note the the "$self->line(...)" argument is 1-based (not zero-base)
  $after = defined($after) ? $after + 1 : 1;

  if (exists($self->{_owners_branch}->{$owner})) {
    my $od = $self->{_owners_branch}->{$owner};
    if (exists($od->{$tla})) {
      my $l = $od->{$tla};
      my $idx = binarySearchLine($l, $after);
      return defined($idx) ? $l->[$idx] : undef;
    }
  }
  return undef;
}


sub _load {
  my $self = shift;
  my $countdata = defined($1) ? shift : undef;

  my $lineno = 0;
  local *HANDLE;                # File handle for reading the diff file

  # Check if file exists and is readable
  stat($self->path());
  if (!(-r _)) {
    return $self->_synthesize($countdata);
  }

  #stat($annotateScript);
  if (!defined($annotateScript)) {
    return $self->_bare_load();
  }

  my $repo_path = Cwd::realpath($self->path());

  my $lineNum = 0;
  my @cmd = split(' ', $annotateScript);
  splice(@cmd, 1, 0, $repo_path);
  my $cmd = join(' ', @cmd);
  lcovutil::info("annotate: '$cmd'\n");
  if (open(HANDLE, "-|", $cmd)) {
    while (my $line = <HANDLE>) {
      chomp $line;
      ++ $lineNum;
      # Also remove CR from line-end
      s/\015$//;

      my ($commit, $owner, $when, $text) = split(/\|/, $line, 4);
      my $age;
      if ($commit ne 'NONE') {
          if ($when =~ /^[0-9]+$/) {
              # a hack for the production of my paper:
              #   if the 'when' value is an integer, treat it as a day count
              #   (rather than a date) - so I can have a stable HTML result
              #   (where age does not change every time I run the example).
              $age = $when;
          } else {
              $age = DateTime::Format::W3CDTF->parse_datetime($when)->delta_days(DateTime->now())->in_units('days');
          }
          defined($owner) or
              die("owner is undef for $repo_path:$lineNum");
          $self->{_owners}->{$owner} = {}
              unless exists($self->{_owners}->{$owner});
          my $dhash = $self->{_owners}->{$owner};
          $dhash->{lines} = []
            unless exists($dhash->{lines});
          push(@{$dhash->{lines}}, $lineNum);
      } else {
          $age = undef;
          $owner = undef;
      }
      push @{$self->{_lines}}, SourceLine->new($owner, $age, $lineNum, $text);
    }
    close(HANDLE);
  }
  else {
    print("Error: 'open(-| $cmd)' failed");
  }
  return $self;
}

sub _synthesize {
  my $self = shift;
  my $countdata = defined($1) ? shift : undef;

  my $lineno = 0;
  local *HANDLE;                # File handle for reading the diff file

  # Synthesize source data from coverage trace to replace unreadable file
  my @lines;
  my $last_line = 0;

  lcovutil::ignorable_error($ERROR_SOURCE, "cannot read " . $self->path());

  return $self if (!defined($countdata));
  @lines = sort( { $a <=> $b }  $countdata->keylist());
  if (@lines) {
    $last_line = $lines[scalar(@lines) - 1];
  }
  return $self if ($last_line < 1);

  # Simulate gcov behavior
  for (my $line = 1 ; $line <= $last_line ; $line++) {
    push @{$self->{_lines}}, SourceLine->new(undef, undef, $line, "/* EOF */");
  }
  return $self;
}

sub _bare_load {
  my $self = shift;

  my $lineno = 0;
  local *HANDLE;                # File handle for reading the diff file

  if (open(HANDLE, "<", $self->path())) {
    while (my $line = <HANDLE>) {
      chomp $line;
      # Also remove CR from line-end
      s/\015$//;

      $lineno++;
      push @{$self->{_lines}}, SourceLine->new(undef, undef, $lineno, $line);
    }
    close(HANDLE);
  }
  return $self;
}




package main;

# Global variables & initialization

# Instance containing all data from the 'current' .info file
our $current_data = TraceFile->new();
# Instance containing all data from the baseline .info file (if any)
our $base_data = TraceFile->new();
# Instance containing all data from diff file
our $diff_data = LineMap->new();
our @opt_dir_prefix;    # Array of prefixes to remove from all sub directories
our @dir_prefix;
our %test_description;  # Hash containing test descriptions if available
our $date = get_date_string(undef);

our @info_filenames;    # List of .info files to use as data source
our $test_title;        # Title for output as written to each page header
our $output_directory;  # Name of directory in which to store output
our $base_filename;     # Optional name of file containing baseline data
our $baseline_title;    # Optional name of baseline - written to page headers
our $baseline_date;     # Optional date that baseline was created
our $diff_filename;     # Optional name of file containing baseline data
our $strip;             # If set, strip leading directories when applying diff
our $desc_filename;     # Name of file containing test descriptions
our $css_filename;      # Optional name of external stylesheet file to use
our $quiet;             # If set, suppress information messages
our $help;              # Help option flag
our $version;           # Version option flag
our $show_details;      # If set, generate detailed directory view
our $no_prefix;         # If set, do not remove filename prefix
our $func_coverage;     # If set, generate function coverage statistics
our $no_func_coverage;  # Disable func_coverage
our $br_coverage;       # If set, generate branch coverage statistics
our $no_br_coverage;    # Disable br_coverage
our $show_tla;          # categorize coverage data (or not)
our $show_dateBins;     # show last modified and last author info
our $show_ownerBins;    # show list of people who have edited code
                        #   (in this file/this directory/etc)
our $show_nonCodeOwners;# show last modified and last author info for
                        #  non-code lines (e.g., comments)

our $sort = 1;          # If set, provide directory listings with sorted entries
our $no_sort;           # Disable sort
our $frames;            # If set, use frames for source code view
our $keep_descriptions; # If set, do not remove unused test case descriptions
our $no_sourceview;     # If set, do not create a source code view for each file
our $highlight;         # If set, highlight lines covered by converted data only
our $legend;            # If set, include legend in output
our $tab_size = 8;      # Number of spaces to use in place of tab
our $config;            # Configuration file contents
our $html_prolog_file;  # Custom HTML prolog file (up to and including <body>)
our $html_epilog_file;  # Custom HTML epilog file (from </body> onwards)
our $html_prolog;       # Actual HTML prolog
our $html_epilog;       # Actual HTML epilog
our $html_ext = "html"; # Extension for generated HTML files
our $html_gzip = 0;     # Compress with gzip
our $demangle_cpp = 0;  # Demangle C++ function names
our @opt_ignore_errors; # Ignore certain error classes during processing
our @opt_filter;        # Filter out requested coverpoints
our @ignore;
our $opt_config_file;   # User-specified configuration file location
our %opt_rc;
our $opt_missed;        # List/sort lines by missed counts
our $charset = "UTF-8"; # Default charset for HTML pages
our @fileview_sortlist;
our @fileview_sortname = ("", "-sort-l", "-sort-f", "-sort-b");
our @fileview_prefixes = ("");
our @funcview_sortlist;
our @rate_name = ("Lo", "Med", "Hi");
our @rate_png = ("ruby.png", "amber.png", "emerald.png");
our $lcov_func_coverage = 1;
our $lcov_branch_coverage = 0;
our $rc_desc_html = 0;  # lcovrc: genhtml_desc_html

our $cwd = cwd();       # Current working directory


#
# Code entry point
#

$SIG{__WARN__} = \&lcovutil::warn_handler;
$SIG{__DIE__} = \&lcovutil::die_handler;

STDERR->autoflush;
STDOUT->autoflush;

# Check command line for a configuration file name
Getopt::Long::Configure("pass_through", "no_auto_abbrev");
GetOptions("config-file=s" => \$opt_config_file,
           "rc=s%" => \%opt_rc);
Getopt::Long::Configure("default");

{
        # Remove spaces around rc options
        my %new_opt_rc;

        while (my ($key, $value) = each(%opt_rc)) {
                $key =~ s/^\s+|\s+$//g;
                $value =~ s/^\s+|\s+$//g;

                $new_opt_rc{$key} = $value;
        }
        %opt_rc = %new_opt_rc;
}

# Read configuration file if available
if (defined($opt_config_file)) {
        $config = read_config($opt_config_file);
} elsif (defined($ENV{"HOME"}) && (-r $ENV{"HOME"}."/.lcovrc"))
{
        $config = read_config($ENV{"HOME"}."/.lcovrc");
}
elsif (-r "/etc/lcovrc")
{
        $config = read_config("/etc/lcovrc");
} elsif (-r "/usr/local/etc/lcovrc")
{
        $config = read_config("/usr/local/etc/lcovrc");
}

if ($config || %opt_rc)
{
        # Copy configuration file and --rc values to variables
        apply_config({
                "genhtml_css_file"              => \$css_filename,
                "genhtml_hi_limit"              => \$hi_limit,
                "genhtml_med_limit"             => \$med_limit,
                "genhtml_line_field_width"      => \$line_field_width,
                "genhtml_overview_width"        => \$overview_width,
                "genhtml_nav_resolution"        => \$nav_resolution,
                "genhtml_nav_offset"            => \$nav_offset,
                "genhtml_keep_descriptions"     => \$keep_descriptions,
                "genhtml_no_prefix"             => \$no_prefix,
                "genhtml_no_source"             => \$no_sourceview,
                "genhtml_num_spaces"            => \$tab_size,
                "genhtml_highlight"             => \$highlight,
                "genhtml_legend"                => \$legend,
                "genhtml_html_prolog"           => \$html_prolog_file,
                "genhtml_html_epilog"           => \$html_epilog_file,
                "genhtml_html_extension"        => \$html_ext,
                "genhtml_html_gzip"             => \$html_gzip,
                "genhtml_precision"             => \$default_precision,
                "genhtml_function_hi_limit"     => \$fn_hi_limit,
                "genhtml_function_med_limit"    => \$fn_med_limit,
                "genhtml_function_coverage"     => \$func_coverage,
                "genhtml_branch_hi_limit"       => \$br_hi_limit,
                "genhtml_branch_med_limit"      => \$br_med_limit,
                "genhtml_branch_coverage"       => \$br_coverage,
                "genhtml_branch_field_width"    => \$br_field_width,
                "genhtml_sort"                  => \$sort,
                "genhtml_charset"               => \$charset,
                "genhtml_desc_html"             => \$rc_desc_html,
                "genhtml_demangle_cpp"          => \$demangle_cpp,
                "genhtml_missed"                => \$opt_missed,
                "lcov_function_coverage"        => \$lcov_func_coverage,
                "lcov_branch_coverage"          => \$lcov_branch_coverage,
                });
}

# Copy related values if not specified
$fn_hi_limit    = $hi_limit if (!defined($fn_hi_limit));
$fn_med_limit   = $med_limit if (!defined($fn_med_limit));
$br_hi_limit    = $hi_limit if (!defined($br_hi_limit));
$br_med_limit   = $med_limit if (!defined($br_med_limit));
$func_coverage  = $lcov_func_coverage if (!defined($func_coverage));
$br_coverage    = $lcov_branch_coverage if (!defined($br_coverage));

# Parse command line options
my @datebins;
if (!GetOptions("output-directory|o=s"  => \$output_directory,
                "title|t=s"             => \$test_title,
                "description-file|d=s"  => \$desc_filename,
                "keep-descriptions|k"   => \$keep_descriptions,
                "css-file|c=s"          => \$css_filename,
                "baseline-file|b=s"     => \$base_filename,
                "baseline-title=s"      => \$baseline_title,
                "baseline-date=s"       => \$baseline_date,
                "diff-file=s"           => \$diff_filename,
                "annotate-script=s"     => \$SourceFile::annotateScript,
                # if 'show-owners' is set: generate the owner table
                #    if it is passed a value: show all the owners,
                #    regardless of whether thay have uncovered code or not
                'show-owners:s'         => \$show_ownerBins,
                'show-noncode'          => \$show_nonCodeOwners,
                "date=s"                => \@datebins,
                "prefix|p=s"            => \@opt_dir_prefix,
                "num-spaces=i"          => \$tab_size,
                "no-prefix"             => \$no_prefix,
                "no-sourceview"         => \$no_sourceview,
                "show-details|s"        => \$show_details,
                "frames|f"              => \$frames,
                "highlight"             => \$highlight,
                "legend"                => \$legend,
                "quiet|q"               => \$quiet,
                "verbose|v"             => \$lcovutil::verbose,
                "help|h|?"              => \$help,
                "version|v"             => \$version,
                "html-prolog=s"         => \$html_prolog_file,
                "html-epilog=s"         => \$html_epilog_file,
                "html-extension=s"      => \$html_ext,
                "html-gzip"             => \$html_gzip,
                "function-coverage"     => \$func_coverage,
                "no-function-coverage"  => \$no_func_coverage,
                "branch-coverage"       => \$br_coverage,
                "no-branch-coverage"    => \$no_br_coverage,
                "sort"                  => \$sort,
                "no-sort"               => \$no_sort,
                "demangle-cpp"          => \$demangle_cpp,
                "ignore-errors=s"       => \@opt_ignore_errors,
                "config-file=s"         => \$opt_config_file,
                "rc=s%"                 => \%opt_rc,
                "precision=i"           => \$default_precision,
                "missed"                => \$opt_missed,
                "filter=s"              => \@opt_filter,
                ))
{
  print(STDERR "Use $tool_name --help to get usage information\n");
  exit(1);
} else {
  # Merge options
  $func_coverage = 0
    if ($no_func_coverage);
  $br_coverage = 0
    if ($no_br_coverage);
  # Merge sort options
  $sort = 0
    if ($no_sort);

  $show_tla = 1
    if ($base_filename);

  if ($SourceFile::annotateScript) {
    $show_dateBins = 1;
    if ( 0 == scalar(@datebins) ) {
      # default: 7, 30, 180 days
      @datebins = @SummaryInfo::defaultCutpoints;
    } else {
      @datebins = split(/,/, join(',', @datebins));
    }
    SummaryInfo::setAgeGroups(@datebins);
  } else {
    die("\"--show-owners\" option requires \"--annotate-script\" for revision control integration")
        if defined($show_ownerBins);
    die ("\"--date\" option requires \"--annotate-script\" for revision control integraion")
      if (0 != scalar(@datebins));
  }
  #ignore 'diff' file if no baseline
  if (defined($diff_filename) &&
      ! defined($base_filename) ) {
      die("'--diff-file $diff_filename' ignored when '--baseline lcovInfoFile' is not used.\n");
      $diff_filename = undef;
  }
  push(@fileview_prefixes, "-date")
      if ($show_dateBins);
  push(@fileview_prefixes, "-owner")
      if (defined($show_ownerBins));
}

@info_filenames = @ARGV;

# Check for help option
if ($help)
{
        print_usage(*STDOUT);
        exit(0);
}

# Check for version option
if ($version)
{
        print("$tool_name: $lcov_version\n");
        exit(0);
}

# Determine which errors the user wants us to ignore
parse_ignore_errors(@opt_ignore_errors);

# Determine what coverpoints the user wants to filter
parse_cov_filters(@opt_filter);

# Split the list of prefixes if needed
parse_dir_prefix(@opt_dir_prefix);

# Check for info filename
if (!@info_filenames)
{
        die("No filename specified\n".
            "Use $tool_name --help to get usage information\n");
}

# Generate a title if none is specified
if (!$test_title)
{
        if (scalar(@info_filenames) == 1)
        {
                # Only one filename specified, use it as title
                $test_title = basename($info_filenames[0]);
        }
        else
        {
                # More than one filename specified, used default title
                $test_title = "unnamed";
        }
}

if ($base_filename) {
    if (!$baseline_title) {
        $baseline_title = basename($base_filename);
    }
    if (!$baseline_date) {
        # if not specified, use 'last modified' of baseline trace file
        $baseline_date = get_date_string((stat($base_filename))[9]);
    }
}


# Make sure css_filename is an absolute path (in case we're changing
# directories)
if ($css_filename)
{
        if (!($css_filename =~ /^\/(.*)$/))
        {
                $css_filename = $cwd."/".$css_filename;
        }
}

# Make sure tab_size is within valid range
if ($tab_size < 1)
{
        print(STDERR "ERROR: invalid number of spaces specified: ".
                     "$tab_size!\n");
        exit(1);
}

# Get HTML prolog and epilog
$html_prolog = get_html_prolog($html_prolog_file);
$html_epilog = get_html_epilog($html_epilog_file);

# Issue a warning if --no-sourceview is enabled together with --frames
if ($no_sourceview && defined($frames))
{
        warn("WARNING: option --frames disabled because --no-sourceview ".
             "was specified!\n");
        $frames = undef;
}

# Issue a warning if --no-prefix is enabled together with --prefix
if ($no_prefix && @dir_prefix)
{
        warn("WARNING: option --prefix disabled because --no-prefix was ".
             "specified!\n");
        @dir_prefix = undef;
}

@fileview_sortlist = ($SORT_FILE);
@funcview_sortlist = ($SORT_FILE);

if ($sort) {
        push(@fileview_sortlist, $SORT_LINE);
        push(@fileview_sortlist, $SORT_FUNC) if ($func_coverage);
        push(@fileview_sortlist, $SORT_BRANCH) if ($br_coverage);
        push(@funcview_sortlist, $SORT_LINE);
}

if ($frames)
{
        # Include genpng code needed for overview image generation
        do("$tool_dir/gendiffpng");
}

# Ensure that the c++filt tool is available when using --demangle-cpp
if ($demangle_cpp)
{
        if (system_no_output(3, "c++filt", "--version")) {
                die("ERROR: could not find c++filt tool needed for ".
                    "--demangle-cpp\n");
        }
}

# Make sure precision is within valid range
if ($default_precision < 1 || $default_precision > 4)
{
        die("ERROR: specified precision is out of range (1 to 4)\n");
}


# Make sure output_directory exists, create it if necessary
if ($output_directory)
{
        stat($output_directory);

        if (! -e _)
        {
                create_sub_dir($output_directory);
        }
}

# Do something
gen_html();

exit(0);



#
# print_usage(handle)
#
# Print usage information.
#

sub print_usage(*)
{
        local *HANDLE = $_[0];

        print(HANDLE <<END_OF_USAGE);
Usage: $tool_name [OPTIONS] INFOFILE(S)

Create HTML output for coverage data found in INFOFILE. Note that INFOFILE
may also be a list of filenames.

Misc:
  -h, --help                        Print this help, then exit
  -v, --version                     Print version number, then exit
  -q, --quiet                       Do not print progress messages
      --config-file FILENAME        Specify configuration file location
      --rc SETTING=VALUE            Override configuration file setting
      --ignore-errors ERRORS        Continue after ERRORS (source,unmapped,
                                    empty)

Operation:
  -o, --output-directory OUTDIR     Write HTML output to OUTDIR
  -s, --show-details                Generate detailed directory view
  -d, --description-file DESCFILE   Read test case descriptions from DESCFILE
  -k, --keep-descriptions           Do not remove unused test descriptions
  -b, --baseline-file BASEFILE      Use BASEFILE as baseline file
      --baseline-title STRING       Use STRING a baseline data label in report
      --baseline-date DATE          Use DATE in baseline data label in report
      --annotate-script SCRIPT      Execute SCRIPT to get revision control
                                    history (wraps "git blame" or "p4 annotate")
      --show_owners [all]           Show owner summary table. If optional
                                    value provided, show all the owners,
                                    regardless of whether they have uncovered
                                    code or not.
      --date day[,day,...]          'day' interpreted as integer number of
                                    days, used as upper bound of corresponding
                                    date bin
  -p, --prefix PREFIX               Remove PREFIX from all directory names
      --no-prefix                   Do not remove prefix from directory names
      --(no-)function-coverage      Enable (disable) function coverage display
      --(no-)branch-coverage        Enable (disable) branch coverage display
      --filter FILTERS              FILTERS (branch,line): gnore branchcov
                                    counts on lines which seem to have no
                                    conditionals
                                    Ignore linecov counts on closing brace
                                    of block

HTML output:
  -f, --frames                      Use HTML frames for source code view
  -t, --title TITLE                 Display TITLE in header of all pages
  -c, --css-file CSSFILE            Use external style sheet file CSSFILE
      --no-source                   Do not create source code view
      --num-spaces NUM              Replace tabs with NUM spaces in source view
      --highlight                   Highlight lines with converted-only data
      --legend                      Include color legend in HTML output
      --html-prolog FILE            Use FILE as HTML prolog for generated pages
      --html-epilog FILE            Use FILE as HTML epilog for generated pages
      --html-extension EXT          Use EXT as filename extension for pages
      --html-gzip                   Use gzip to compress HTML
      --(no-)sort                   Enable (disable) sorted coverage views
      --demangle-cpp                Demangle C++ function names
      --precision NUM               Set precision of coverage rate
      --missed                      Show miss counts as negative numbers

For more information see: $lcov_url
END_OF_USAGE
        ;
}


#
# strip_directories($path, $depth)
#
# Remove DEPTH leading directory levels from PATH.
#

sub strip_directories($$)
{
        my $filename = $_[0];
        my $depth = $_[1];
        my $i;

        if (!defined($depth) || ($depth < 1))
        {
                return $filename;
        }
        for ($i = 0; $i < $depth; $i++)
        {
                $filename =~ s/^[^\/]*\/+(.*)$/$1/;
        }
        return $filename;
}

#
# get_rate(found, hit)
#
# Return a relative value for the specified found&hit values
# which is used for sorting the corresponding entries in a
# file list.
#

sub get_rate($$)
{
        my ($found, $hit) = @_;

        if ($found == 0) {
                return 10000;
        }
        return int($hit * 1000 / $found) * 10 + 2 - (1 / $found);
}


#
# get_overall_line(found, hit, name_singular, name_plural)
#
# Return a string containing overall information for the specified
# found/hit data.
#

sub get_overall_line($$$$)
{
        my ($found, $hit, $name_sn, $name_pl) = @_;
        my $name;

        return "no data found" if (!defined($found) || $found == 0);
        $name = ($found == 1) ? $name_sn : $name_pl;
        return rate($hit, $found, "% ($hit of $found $name)");
}


#
# print_overall_rate(ln_do, ln_found, ln_hit, fn_do, fn_found, fn_hit, br_do
#                    br_found, br_hit)
#
# Print overall coverage rates for the specified coverage types.
#

sub print_overall_rate($$$$)
{
        #my $summary = shift;
        #my ($ln_do, $fn_do, $br_do) = @_;
        my ($ln_do, $fn_do, $br_do, $summary) = @_;

        info("Overall coverage rate:\n");
        if ($ln_do) {
          info("  lines......: %s\n",
               get_overall_line($summary->l_found(), $summary->l_hit(), "line", "lines"));
          if ($main::show_tla) {
            for my $tla (@SummaryInfo::tlaPriorityOrder) {
              my $v = $summary->get($tla);
              info("       $tla...: $v\n")
                if $v != 0;
            }
          }
        }
        info("  functions..: %s\n",
             get_overall_line($summary->f_found(), $summary->f_hit(), "function", "functions"))
                if ($fn_do);
        if ($br_do) {
          info("  branches...: %s\n",
               get_overall_line($summary->b_found(), $summary->b_hit(), "branch", "branches"));
          if ($main::show_tla) {
            for my $tla (@SummaryInfo::tlaPriorityOrder) {
              my $v = $summary->get($tla, 'branch');
              info("       $tla...: $v\n")
                if 0 != $v;
            }
          }
        }
        summarize_cov_filters();
}

sub get_fn_list($)
{
        my ($info) = @_;
        my %fns;
        my @result;

        foreach my $filename ($info->files()) {
                foreach my $func_name ($info->data($filename)->func()->keylist()) {
                        $fns{$func_name} = 1;
                }
                foreach my $func_name ($info->data($filename)->sumfnc()->keylist()) {
                        $fns{$func_name} = 1;
                }
        }

        @result = keys(%fns);

        return \@result;
}

#
# gen_html()
#
# Generate a set of HTML pages from contents of .info file INFO_FILENAME.
# Files will be written to the current directory. If provided, test case
# descriptions will be read from .tests file TEST_FILENAME and included
# in ouput.
#
# Die on error.
#

sub gen_html()
{
  local *HTML_HANDLE;
  my %overview;
  my $dir_name;
  my $link_name;
  my @dir_list;
  my $new_info;
  my $summary = SummaryInfo->new("top");
  my $dir_summary;

  # "Read
  my $readSourceFile = ReadCurrentSource->new();

  # Read in all specified .info files
  foreach (@info_filenames)
  {
    $new_info = TraceFile->load($_, $readSourceFile);

    # Combine %new_info with %current_data
    $current_data->append_tracefile($new_info);
  }

  info("Found %d entries.\n", scalar($current_data->files()));

  # Read and apply diff data if specified - need this before we
  #  try to read and process the baseline..
  if ($diff_filename)
  {
    info("Reading diff file $diff_filename\n");
    $diff_data->load($diff_filename);
  }

  # Read and apply baseline data if specified
  if ($base_filename)
  {
    my $readBaseSource = ReadBaselineSource->new($diff_data);
    # Read baseline file
    info("Reading baseline file $base_filename\n");
    $new_info = TraceFile->load($base_filename, $readBaseSource);
    $base_data->append_tracefile($new_info);
    info("Found %d entries.\n", scalar($base_data->files()));
  }

  @dir_list = get_dir_list($current_data->files());

  if ($no_prefix)
  {
    # User requested that we leave filenames alone
    info("User asked not to remove filename prefix\n");
  }
  elsif (! @dir_prefix)
  {
    # Get prefix common to most directories in list
    my $prefix = get_prefix(1, $current_data->files());

    if ($prefix)
    {
      info("Found common filename prefix \"$prefix\"\n");
      $dir_prefix[0] = $prefix;
    }
    else
    {
      info("No common filename prefix found!\n");
      $no_prefix=1;
    }
  }
  else
  {
    my $msg = "Using user-specified filename prefix ";
    for my $i (0 .. $#dir_prefix)
    {
      $dir_prefix[$i] =~ s/\/+$//;
      $msg .= ", " unless 0 == $i;
      $msg .= "\"" . $dir_prefix[$i] . "\"";
    }
    info($msg . "\n");
  }

  # Read in test description file if specified
  if ($desc_filename)
  {
    info("Reading test description file $desc_filename\n");
    %test_description = %{read_testfile($desc_filename)};

    # Remove test descriptions which are not referenced
    # from %current_data if user didn't tell us otherwise
    if (!$keep_descriptions)
    {
      remove_unused_descriptions();
    }
  }

  # Change to output directory if specified
  if ($output_directory)
  {
    if (defined($SourceFile::annotateScript)) {
      chomp($SourceFile::annotateScript);
      my @scr = split(' ', $SourceFile::annotateScript);
      if (! File::Spec->file_name_is_absolute($scr[0])) {
        $scr[0] = File::Spec->rel2abs($scr[0]);
        $SourceFile::annotateScript = join(' ', @scr);
      }
    }
    chdir($output_directory)
        or die("ERROR: cannot change to directory " . "$output_directory!\n");
  }

  info("Writing .css and .png files.\n");
  write_css_file();
  write_png_files();

  if ($html_gzip)
  {
    info("Writing .htaccess file.\n");
    write_htaccess_file();
  }

  info("Generating output.\n");

  # Process each subdirectory and collect overview information
  foreach $dir_name (@dir_list)
  {
    $dir_summary = process_dir($dir_name);

    # Handle files in root directory gracefully
    $dir_name = "root" if ($dir_name eq "");

    # Remove prefix if applicable
    if (!$no_prefix && @dir_prefix)
    {
      # Match directory names beginning with one of @dir_prefix
      $dir_name = apply_prefix($dir_name,@dir_prefix);
    }

    # Generate name for directory overview HTML page
    if ($dir_name =~ /^\/(.*)$/)
    {
      $link_name = substr($dir_name, 1)."/index.$html_ext";
    }
    else
    {
      $link_name = $dir_name."/index.$html_ext";
    }

    $overview{$dir_name} =
        [$dir_summary->l_found(), $dir_summary->l_hit(),
         $dir_summary->f_found(), $dir_summary->f_hit(),
         $dir_summary->b_found(), $dir_summary->b_hit(),
         $link_name,
         get_rate($dir_summary->l_found(), $dir_summary->l_hit()),
         get_rate($dir_summary->f_found(), $dir_summary->f_hit()),
         get_rate($dir_summary->b_found(), $dir_summary->b_hit()),
         $dir_summary];

    $summary->append($dir_summary);
  }

  # Generate overview page
  info("Writing directory view page.\n");

  # Create sorted pagesaa
  foreach my $prefix (@main::fileview_prefixes) {
    foreach (@fileview_sortlist) {
      write_dir_page($prefix, $fileview_sortname[$_], ".", "", $test_title,
                     undef, \%overview, {}, {}, {}, 0, $_, $summary);
    }
  }

  # Check if there are any test case descriptions to write out
  if (%test_description)
  {
    info("Writing test case description file.\n");
    write_description_file( \%test_description, $summary);
  }

  print_overall_rate(1, $func_coverage, $br_coverage, $summary);

  chdir($cwd);
}

#
# html_create(handle, filename)
#

sub html_create($$)
{
  my $handle = $_[0];
  my $filename = $_[1];

  if ($html_gzip)
  {
    open($handle, "|-", "gzip -c >'$filename'")
        or die("ERROR: cannot open $filename for writing (gzip)!\n");
  }
  else
  {
    open($handle, ">", $filename)
        or die("ERROR: cannot open $filename for writing!\n");
  }
}

sub write_dir_page($$$$$$$$$$$$$)
{
  my ($prefix, $name, $rel_dir, $base_dir, $title, $trunc_dir,
      $overview, $testhash, $testfnchash, $testbrhash,
      $view_type, $sort_type, $summary) = @_;

  if ('' ne $prefix &&
      ('sort-l' ne $name &&
       '' ne $name)) {
      # we don't do date- or owner-binning for function or branch coverage, yet
      return;
  }
  # Generate directory overview page including details
  html_create(*HTML_HANDLE, "$rel_dir/index$prefix$name.$html_ext");
  if (!defined($trunc_dir)) {
    $trunc_dir = "";
  }
  $title .= " - " if ($trunc_dir ne "");
  write_html_prolog(*HTML_HANDLE, $base_dir, "LCOV - $title$trunc_dir");
  write_header(*HTML_HANDLE, [$view_type, $sort_type, $prefix],
               $trunc_dir, $rel_dir, $summary, undef);
  write_file_table(*HTML_HANDLE, $base_dir, $overview, $testhash,
                   $testfnchash, $testbrhash, $summary,
                   [$view_type, $sort_type, $prefix, $name]);
  write_html_epilog(*HTML_HANDLE, $base_dir);
  close(*HTML_HANDLE);
}


#
# process_dir(dir_name)
#

sub process_dir($)
{
  my $abs_dir = $_[0];
  my $rel_dir = $abs_dir;
  my %overview;
  my %testhash;
  my %testfnchash;
  my %testbrhash;
  my @sort_list;
  local *HTML_HANDLE;

  # Remove prefix if applicable
  if (!$no_prefix)
  {
    # Match directory name beginning with one of @dir_prefix
    $rel_dir = apply_prefix($rel_dir,@dir_prefix);
  }

  my $trunc_dir = $rel_dir;

  my $summary = SummaryInfo->new("directory", $trunc_dir);

  # Remove leading /
  if ($rel_dir =~ /^\/(.*)$/)
  {
    $rel_dir = substr($rel_dir, 1);
  }

  # Handle files in root directory gracefully
  $rel_dir = "root" if ($rel_dir eq "");
  $trunc_dir = "root" if ($trunc_dir eq "");

  my $base_dir = get_relative_base_path($rel_dir);

  create_sub_dir($rel_dir);

  # Match filenames which specify files in this directory, not including
  # sub-directories
  foreach my $filename (grep(/^\Q$abs_dir\E\/[^\/]*$/,$current_data->files()))
  {
    my ($testdata, $testfncdata, $testbrdata, $file_summary, $fileDetails) =
      process_file($trunc_dir, $rel_dir, $filename);

    my $base_name = basename($filename);

    my $page_link;
    if ($no_sourceview) {
      $page_link = "";
    } elsif ($frames) {
      # Link to frameset page
      $page_link = "$base_name.gcov.frameset.$html_ext";
    } else {
      # Link directory to source code view page
      $page_link = "$base_name.gcov.$html_ext";
    }

    $overview{$base_name} =
        [$file_summary->l_found(), $file_summary->l_hit(),
         $file_summary->f_found(), $file_summary->f_hit(),
         $file_summary->b_found(), $file_summary->b_hit(),
         $page_link,
         get_rate($file_summary->l_found(), $file_summary->l_hit()),
         get_rate($file_summary->f_found(), $file_summary->f_hit()),
         get_rate($file_summary->b_found(), $file_summary->b_hit()),
         $file_summary, $fileDetails];

    $testhash{$base_name} = $testdata;
    $testfnchash{$base_name} = $testfncdata;
    $testbrhash{$base_name} = $testbrdata;

    $summary->append($file_summary);
  }

  # Create sorted pages
  foreach my $prefix (@fileview_prefixes) {
    foreach (@fileview_sortlist) {
      # Generate directory overview page (without details)
      write_dir_page($prefix, $fileview_sortname[$_], $rel_dir, $base_dir,
                     $test_title, $trunc_dir, \%overview, {},
                     {}, {}, 1, $_, $summary);
      next
        unless $show_details;

      # Generate directory overview page including details
      write_dir_page($prefix, "-detail".$fileview_sortname[$_], $rel_dir,
                     $base_dir, $test_title, $trunc_dir,
                     \%overview, \%testhash, \%testfnchash,
                     \%testbrhash, 1, $_, $summary);
    }
  }

  # Calculate resulting line counts
  return ($summary);
}


sub write_function_page($$$$$$$$$$$$$)
{
  my ($base_dir, $rel_dir, $trunc_dir, $base_name, $title,
      $sumcount, $funcdata, $sumfnccount, $testfncdata, $sumbrcount,
      $testbrdata, $sort_type, $summary) = @_;
  my $pagetitle;
  my $filename;

  # Generate function table for this file
  if ($sort_type == 0) {
    $filename = "$rel_dir/$base_name.func.$html_ext";
  } else {
    $filename = "$rel_dir/$base_name.func-sort-c.$html_ext";
  }
  html_create(*HTML_HANDLE, $filename);
  $pagetitle = "LCOV - $title - $trunc_dir/$base_name - functions";
  write_html_prolog(*HTML_HANDLE, $base_dir, $pagetitle);
  write_header(*HTML_HANDLE, [4, $sort_type], "$trunc_dir/$base_name",
               "$rel_dir/$base_name", $summary, undef);
  write_function_table(*HTML_HANDLE, "$base_name.gcov.$html_ext",
                       $sumcount, $funcdata,
                       $sumfnccount, $testfncdata, $sumbrcount,
                       $testbrdata, $base_name,
                       $base_dir, $sort_type);
  write_html_epilog(*HTML_HANDLE, $base_dir, 1);
  close(*HTML_HANDLE);
}


#
# process_file(trunc_dir, rel_dir, filename)
#

sub process_file($$$)
{
  my $trunc_name = apply_prefix($_[2], @dir_prefix);
  info("Processing file $trunc_name\n");

  my $trunc_dir = $_[0];
  my $rel_dir = $_[1];
  my $filename = $_[2];
  my $base_name = basename($filename);
  my $base_dir = get_relative_base_path($rel_dir);
  my $testdata;
  my $sumcount;
  my $funcdata;
  my $checkdata;
  my $testfncdata;
  my $sumfnccount;
  my $testbrdata;
  my $sumbrcount;
  my $summary = SummaryInfo->new("file", $trunc_name);
  my $lines_found;
  my $lines_hit;
  my $fn_found;
  my $fn_hit;
  my $br_found;
  my $br_hit;
  my $converted;
  my $nonconverted;
  my $lineCovInfo;
  my @source;
  my $pagetitle;
  local *HTML_HANDLE;

  ($testdata, $sumcount, $funcdata, $checkdata, $testfncdata,
   $sumfnccount, $testbrdata, $sumbrcount, $lines_found, $lines_hit,
   $fn_found, $fn_hit, $br_found, $br_hit)
    = $current_data->data($filename)->get_info();

  $summary->l_found($lines_found);
  $summary->l_hit($lines_hit);

  $summary->f_found($fn_found);
  $summary->f_hit($fn_hit);

  $summary->b_found($br_found);
  $summary->b_hit($br_hit);

  # Return after this point in case user asked us not to generate
  # source code view
  if ($no_sourceview)
  {
    return ($testdata, $testfncdata, $testbrdata, $summary);
  }

  # build coverage differential categories
  $lineCovInfo = LineCoverageInfo->new($filename, $base_data, $current_data,
                                       $diff_data
                                       #, scalar($filename =~ /vcsapi_type/)
      );

  info("  lines=".$lines_found." hit=".$lines_hit."\n");

  # NOTE: $summary struct is also modified: update total counts
  #   in each bucket, counts in each date range
  my $srcfile = SourceFile->new($filename, $summary, $lineCovInfo, $sumcount);

  # Generate source code view for this file
  html_create(*HTML_HANDLE, "$rel_dir/$base_name.gcov.$html_ext");
  $pagetitle = "LCOV - $test_title - $trunc_dir/$base_name";
  write_html_prolog(*HTML_HANDLE, $base_dir, $pagetitle);
  write_header(*HTML_HANDLE, [2, 0], "$trunc_dir/$base_name",
               "$rel_dir/$base_name", $summary, $srcfile);

  @source = write_source(*HTML_HANDLE, $srcfile, $sumcount, $checkdata,
                         $lineCovInfo, $funcdata, $sumbrcount);

  write_html_epilog(*HTML_HANDLE, $base_dir, 1);
  close(*HTML_HANDLE);

  if ($func_coverage) {
    # Create function tables
    foreach (@funcview_sortlist) {
      write_function_page($base_dir, $rel_dir, $trunc_dir,
                          $base_name, $test_title,
                          $sumcount, $funcdata, $sumfnccount,
                          $testfncdata, $sumbrcount,
                          $testbrdata, $_, $summary);
    }
  }

  # Additional files are needed in case of frame output
  if ($frames)
  {
    # Create overview png file
    gen_png("$rel_dir/$base_name.gcov.png", $overview_width, $tab_size, @source);

    # Create frameset page
    html_create(*HTML_HANDLE, "$rel_dir/$base_name.gcov.frameset.$html_ext");
    write_frameset(*HTML_HANDLE, $base_dir, $base_name, $pagetitle);
    close(*HTML_HANDLE);

    # Write overview frame
    html_create(*HTML_HANDLE, "$rel_dir/$base_name.gcov.overview.$html_ext");
    write_overview(*HTML_HANDLE, $base_dir, $base_name, $pagetitle,
                   scalar(@source));
    close(*HTML_HANDLE);
  }

  return ($testdata, $testfncdata, $testbrdata, $summary, $srcfile);
}


sub compress_brcount($)
{
  my ($brcount) = @_;
  my $db;

  $db = brcount_to_db($brcount);
  return db_to_brcount($db, $brcount);
}

#
# get_info_entry(hash_ref)
#
# Retrieve data from an entry of the structure generated by read_info_file().
# Return a list of references to hashes:
# (test data hash ref, sum count hash ref, funcdata hash ref, checkdata hash
#  ref, testfncdata hash ref, sumfnccount hash ref, lines found, lines hit,
#  functions found, functions hit)
#

sub get_info_entry($)
{
  my $testdata_ref = $_[0]->{"test"};
  my $sumcount_ref = $_[0]->{"sum"};
  my $funcdata_ref = $_[0]->{"func"};
  my $checkdata_ref = $_[0]->{"check"};
  my $testfncdata = $_[0]->{"testfnc"};
  my $sumfnccount = $_[0]->{"sumfnc"};
  my $testbrdata = $_[0]->{"testbr"};
  my $sumbrcount = $_[0]->{"sumbr"};
  my $lines_found = $_[0]->{"found"};
  my $lines_hit = $_[0]->{"hit"};
  my $fn_found = $_[0]->{"f_found"};
  my $fn_hit = $_[0]->{"f_hit"};
  my $br_found = $_[0]->{"b_found"};
  my $br_hit = $_[0]->{"b_hit"};

  return ($testdata_ref, $sumcount_ref, $funcdata_ref, $checkdata_ref,
          $testfncdata, $sumfnccount, $testbrdata, $sumbrcount,
          $lines_found, $lines_hit, $fn_found, $fn_hit,
          $br_found, $br_hit);
}


#
# set_info_entry(hash_ref, testdata_ref, sumcount_ref, funcdata_ref,
#                checkdata_ref, testfncdata_ref, sumfcncount_ref,
#                testbrdata_ref, sumbrcount_ref[,lines_found,
#                lines_hit, f_found, f_hit, $b_found, $b_hit])
#
# Update the hash referenced by HASH_REF with the provided data references.
#

sub set_info_entry($$$$$$$$$;$$$$$$)
{
  my $data_ref = $_[0];

  $data_ref->{"test"} = $_[1];
  $data_ref->{"sum"} = $_[2];
  $data_ref->{"func"} = $_[3];
  $data_ref->{"check"} = $_[4];
  $data_ref->{"testfnc"} = $_[5];
  $data_ref->{"sumfnc"} = $_[6];
  $data_ref->{"testbr"} = $_[7];
  $data_ref->{"sumbr"} = $_[8];

  if (defined($_[9])) { $data_ref->{"found"} = $_[9]; }
  if (defined($_[10])) { $data_ref->{"hit"} = $_[10]; }
  if (defined($_[11])) { $data_ref->{"f_found"} = $_[11]; }
  if (defined($_[12])) { $data_ref->{"f_hit"} = $_[12]; }
  if (defined($_[13])) { $data_ref->{"b_found"} = $_[13]; }
  if (defined($_[14])) { $data_ref->{"b_hit"} = $_[14]; }
}


#
# add_counts(data1_ref, data2_ref)
#
# DATA1_REF and DATA2_REF are references to hashes containing a mapping
#
#   line number -> execution count
#
# Return a list (RESULT_REF, LINES_FOUND, LINES_HIT) where RESULT_REF
# is a reference to a hash containing the combined mapping in which
# execution counts are added.
#

sub add_counts($$)
{
        my $data1_ref = $_[0];  # Hash 1
        my $data2_ref = $_[1];  # Hash 2
        my %result;             # Resulting hash
        my $line;               # Current line iteration scalar
        my $data1_count;        # Count of line in hash1
        my $data2_count;        # Count of line in hash2
        my $found = 0;          # Total number of lines found
        my $hit = 0;            # Number of lines with a count > 0

        foreach $line (keys(%$data1_ref))
        {
                $data1_count = $data1_ref->{$line};
                $data2_count = $data2_ref->{$line};

                # Add counts if present in both hashes
                if (defined($data2_count)) { $data1_count += $data2_count; }

                # Store sum in %result
                $result{$line} = $data1_count;

                $found++;
                if ($data1_count > 0) { $hit++; }
        }

        # Add lines unique to data2_ref
        foreach $line (keys(%$data2_ref))
        {
                # Skip lines already in data1_ref
                if (defined($data1_ref->{$line})) { next; }

                # Copy count from data2_ref
                $result{$line} = $data2_ref->{$line};

                $found++;
                if ($result{$line} > 0) { $hit++; }
        }

        return (\%result, $found, $hit);
}


#
# merge_checksums(ref1, ref2, filename)
#
# REF1 and REF2 are references to hashes containing a mapping
#
#   line number -> checksum
#
# Merge checksum lists defined in REF1 and REF2 and return reference to
# resulting hash. Die if a checksum for a line is defined in both hashes
# but does not match.
#

sub merge_checksums($$$)
{
        my $ref1 = $_[0];
        my $ref2 = $_[1];
        my $filename = $_[2];
        my %result;
        my $line;

        foreach $line (keys(%{$ref1}))
        {
                if (defined($ref2->{$line}) &&
                    ($ref1->{$line} ne $ref2->{$line}))
                {
                        die("ERROR: checksum mismatch at $filename:$line\n");
                }
                $result{$line} = $ref1->{$line};
        }

        foreach $line (keys(%{$ref2}))
        {
                $result{$line} = $ref2->{$line};
        }

        return \%result;
}


#
# merge_func_data(funcdata1, funcdata2, filename)
#

sub merge_func_data($$$)
{
        my ($funcdata1, $funcdata2, $filename) = @_;
        my %result;
        my $func;

        if (defined($funcdata1)) {
                %result = %{$funcdata1};
        }

        foreach $func (keys(%{$funcdata2})) {
                my $line1 = $result{$func};
                my $line2 = $funcdata2->{$func};

                if (defined($line1) && ($line1 != $line2)) {
                        warn("WARNING: function data mismatch at ".
                             "$filename:$line2\n");
                        next;
                }
                $result{$func} = $line2;
        }

        return \%result;
}


#
# add_fnccount(fnccount1, fnccount2)
#
# Add function call count data. Return list (fnccount_added, f_found, f_hit)
#

sub add_fnccount($$)
{
        my ($fnccount1, $fnccount2) = @_;
        my %result;
        my $fn_found;
        my $fn_hit;
        my $function;

        if (defined($fnccount1)) {
                %result = %{$fnccount1};
        }
        foreach $function (keys(%{$fnccount2})) {
                $result{$function} += $fnccount2->{$function};
        }
        $fn_found = scalar(keys(%result));
        $fn_hit = 0;
        foreach $function (keys(%result)) {
                if ($result{$function} > 0) {
                        $fn_hit++;
                }
        }

        return (\%result, $fn_found, $fn_hit);
}

#
# add_testfncdata(testfncdata1, testfncdata2)
#
# Add function call count data for several tests. Return reference to
# added_testfncdata.
#

sub add_testfncdata($$)
{
        my ($testfncdata1, $testfncdata2) = @_;
        my %result;
        my $testname;

        foreach $testname (keys(%{$testfncdata1})) {
                if (defined($testfncdata2->{$testname})) {
                        my $fnccount;

                        # Function call count data for this testname exists
                        # in both data sets: add
                        ($fnccount) = add_fnccount(
                                $testfncdata1->{$testname},
                                $testfncdata2->{$testname});
                        $result{$testname} = $fnccount;
                        next;
                }
                # Function call count data for this testname is unique to
                # data set 1: copy
                $result{$testname} = $testfncdata1->{$testname};
        }

        # Add count data for testnames unique to data set 2
        foreach $testname (keys(%{$testfncdata2})) {
                if (!defined($result{$testname})) {
                        $result{$testname} = $testfncdata2->{$testname};
                }
        }
        return \%result;
}


#
# brcount_to_db(brcount)
#
# Convert brcount data to the following format:
#
# db:          line number    -> block hash
# block hash:  block number   -> branch hash
# branch hash: branch number  -> taken value
#

sub brcount_to_db($)
{
        my ($brcount) = @_;
        my $line;
        my $db;

        # Add branches to database
        foreach $line (keys(%{$brcount})) {
                my $brdata = $brcount->{$line};

                foreach my $entry (split(/:/, $brdata)) {
                        my ($block, $branch, $taken) = split(/,/, $entry);
                        my $old = $db->{$line}->{$block}->{$branch};

                        if (!defined($old) || $old eq "-") {
                                $old = $taken;
                        } elsif ($taken ne "-") {
                                $old += $taken;
                        }

                        $db->{$line}->{$block}->{$branch} = $old;
                }
        }

        return $db;
}


#
# db_to_brcount(db[, brcount])
#
# Convert branch coverage data back to brcount format. If brcount is specified,
# the converted data is directly inserted in brcount.
#

sub db_to_brcount($;$)
{
        my ($db, $brcount) = @_;
        my $line;
        my $br_found = 0;
        my $br_hit = 0;

        # Convert database back to brcount format
        foreach $line (sort({$a <=> $b} keys(%{$db}))) {
                my $ldata = $db->{$line};
                my $brdata;
                my $block;

                foreach $block (sort({$a <=> $b} keys(%{$ldata}))) {
                        my $bdata = $ldata->{$block};
                        my $branch;

                        foreach $branch (sort({$a <=> $b} keys(%{$bdata}))) {
                                my $taken = $bdata->{$branch};

                                $br_found++;
                                $br_hit++ if ($taken ne "-" && $taken > 0);
                                $brdata .= "$block,$branch,$taken:";
                        }
                }
                $brcount->{$line} = $brdata;
        }

        return ($brcount, $br_found, $br_hit);
}


#
# brcount_db_combine(db1, db2, op)
#
# db1 := db1 op db2, where
#   db1, db2: brcount data as returned by brcount_to_db
#   op:       one of $BR_ADD and BR_SUB
#
sub brcount_db_combine($$$)
{
        my ($db1, $db2, $op) = @_;

        foreach my $line (keys(%{$db2})) {
                my $ldata = $db2->{$line};

                foreach my $block (keys(%{$ldata})) {
                        my $bdata = $ldata->{$block};

                        foreach my $branch (keys(%{$bdata})) {
                                my $taken = $bdata->{$branch};
                                my $new = $db1->{$line}->{$block}->{$branch};

                                if (!defined($new) || $new eq "-") {
                                        $new = $taken;
                                } elsif ($taken ne "-") {
                                        if ($op == $BR_ADD) {
                                                $new += $taken;
                                        } elsif ($op == $BR_SUB) {
                                                $new -= $taken;
                                                $new = 0 if ($new < 0);
                                        }
                                }

                                $db1->{$line}->{$block}->{$branch} = $new;
                        }
                }
        }
}


#
# brcount_db_get_found_and_hit(db)
#
# Return (br_found, br_hit) for db.
#

sub brcount_db_get_found_and_hit($)
{
        my ($db) = @_;
        my ($br_found , $br_hit) = (0, 0);

        foreach my $line (keys(%{$db})) {
                my $ldata = $db->{$line};

                foreach my $block (keys(%{$ldata})) {
                        my $bdata = $ldata->{$block};

                        foreach my $branch (keys(%{$bdata})) {
                                my $taken = $bdata->{$branch};

                                $br_found++;
                                $br_hit++ if ($taken ne "-" && $taken > 0);
                        }
                }
        }

        return ($br_found, $br_hit);
}


# combine_brcount(brcount1, brcount2, type, inplace)
#
# If add is BR_ADD, add branch coverage data and return list brcount_added.
# If add is BR_SUB, subtract the taken values of brcount2 from brcount1 and
# return brcount_sub. If inplace is set, the result is inserted into brcount1.
#

sub combine_brcount($$$;$)
{
        my ($brcount1, $brcount2, $type, $inplace) = @_;
        my ($db1, $db2);

        $db1 = brcount_to_db($brcount1);
        $db2 = brcount_to_db($brcount2);
        brcount_db_combine($db1, $db2, $type);

        return db_to_brcount($db1, $inplace ? $brcount1 : undef);
}


#
# add_testbrdata(testbrdata1, testbrdata2)
#
# Add branch coverage data for several tests. Return reference to
# added_testbrdata.
#

sub add_testbrdata($$)
{
        my ($testbrdata1, $testbrdata2) = @_;
        my %result;
        my $testname;

        foreach $testname (keys(%{$testbrdata1})) {
                if (defined($testbrdata2->{$testname})) {
                        my $brcount;

                        # Branch coverage data for this testname exists
                        # in both data sets: add
                        ($brcount) = combine_brcount($testbrdata1->{$testname},
                                         $testbrdata2->{$testname}, $BR_ADD);
                        $result{$testname} = $brcount;
                        next;
                }
                # Branch coverage data for this testname is unique to
                # data set 1: copy
                $result{$testname} = $testbrdata1->{$testname};
        }

        # Add count data for testnames unique to data set 2
        foreach $testname (keys(%{$testbrdata2})) {
                if (!defined($result{$testname})) {
                        $result{$testname} = $testbrdata2->{$testname};
                }
        }
        return \%result;
}


#
# combine_info_entries(entry_ref1, entry_ref2, filename)
#
# Combine .info data entry hashes referenced by ENTRY_REF1 and ENTRY_REF2.
# Return reference to resulting hash.
#

sub combine_info_entries($$$)
{
        my $entry1 = $_[0];     # Reference to hash containing first entry
        my $testdata1;
        my $sumcount1;
        my $funcdata1;
        my $checkdata1;
        my $testfncdata1;
        my $sumfnccount1;
        my $testbrdata1;
        my $sumbrcount1;

        my $entry2 = $_[1];     # Reference to hash containing second entry
        my $testdata2;
        my $sumcount2;
        my $funcdata2;
        my $checkdata2;
        my $testfncdata2;
        my $sumfnccount2;
        my $testbrdata2;
        my $sumbrcount2;

        my %result;             # Hash containing combined entry
        my %result_testdata;
        my $result_sumcount = {};
        my $result_funcdata;
        my $result_testfncdata;
        my $result_sumfnccount;
        my $result_testbrdata;
        my $result_sumbrcount;
        my $lines_found;
        my $lines_hit;
        my $fn_found;
        my $fn_hit;
        my $br_found;
        my $br_hit;

        my $testname;
        my $filename = $_[2];

        # Retrieve data
        ($testdata1, $sumcount1, $funcdata1, $checkdata1, $testfncdata1,
         $sumfnccount1, $testbrdata1, $sumbrcount1) = get_info_entry($entry1);
        ($testdata2, $sumcount2, $funcdata2, $checkdata2, $testfncdata2,
         $sumfnccount2, $testbrdata2, $sumbrcount2) = get_info_entry($entry2);

        # Merge checksums
        $checkdata1 = merge_checksums($checkdata1, $checkdata2, $filename);

        # Combine funcdata
        $result_funcdata = merge_func_data($funcdata1, $funcdata2, $filename);

        # Combine function call count data
        $result_testfncdata = add_testfncdata($testfncdata1, $testfncdata2);
        ($result_sumfnccount, $fn_found, $fn_hit) =
                add_fnccount($sumfnccount1, $sumfnccount2);

        # Combine branch coverage data
        $result_testbrdata = add_testbrdata($testbrdata1, $testbrdata2);
        ($result_sumbrcount, $br_found, $br_hit) =
                combine_brcount($sumbrcount1, $sumbrcount2, $BR_ADD);

        # Combine testdata
        foreach $testname (keys(%{$testdata1}))
        {
                if (defined($testdata2->{$testname}))
                {
                        # testname is present in both entries, requires
                        # combination
                        ($result_testdata{$testname}) =
                                add_counts($testdata1->{$testname},
                                           $testdata2->{$testname});
                }
                else
                {
                        # testname only present in entry1, add to result
                        $result_testdata{$testname} = $testdata1->{$testname};
                }

                # update sum count hash
                ($result_sumcount, $lines_found, $lines_hit) =
                        add_counts($result_sumcount,
                                   $result_testdata{$testname});
        }

        foreach $testname (keys(%{$testdata2}))
        {
                # Skip testnames already covered by previous iteration
                if (defined($testdata1->{$testname})) { next; }

                # testname only present in entry2, add to result hash
                $result_testdata{$testname} = $testdata2->{$testname};

                # update sum count hash
                ($result_sumcount, $lines_found, $lines_hit) =
                        add_counts($result_sumcount,
                                   $result_testdata{$testname});
        }

        # Calculate resulting sumcount

        # Store result
        set_info_entry(\%result, \%result_testdata, $result_sumcount,
                       $result_funcdata, $checkdata1, $result_testfncdata,
                       $result_sumfnccount, $result_testbrdata,
                       $result_sumbrcount, $lines_found, $lines_hit,
                       $fn_found, $fn_hit, $br_found, $br_hit);

        return(\%result);
}


#
# combine_info_files(info_ref1, info_ref2)
#
# Combine .info data in hashes referenced by INFO_REF1 and INFO_REF2. Return
# reference to resulting hash.
#

sub combine_info_files($$)
{
        my %hash1 = %{$_[0]};
        my %hash2 = %{$_[1]};
        my $filename;

        foreach $filename (keys(%hash2))
        {
                if ($hash1{$filename})
                {
                        # Entry already exists in hash1, combine them
                        $hash1{$filename} =
                                combine_info_entries($hash1{$filename},
                                                     $hash2{$filename},
                                                     $filename);
                }
                else
                {
                        # Entry is unique in both hashes, simply add to
                        # resulting hash
                        $hash1{$filename} = $hash2{$filename};
                }
        }

        return(\%hash1);
}


#
# get_prefix(min_dir, filename_list)
#
# Search FILENAME_LIST for a directory prefix which is common to as many
# list entries as possible, so that removing this prefix will minimize the
# sum of the lengths of all resulting shortened filenames while observing
# that no filename has less than MIN_DIR parent directories.
#

sub get_prefix($@)
{
        my ($min_dir, @filename_list) = @_;
        my %prefix;                     # mapping: prefix -> sum of lengths
        my $current;                    # Temporary iteration variable

        # Find list of prefixes
        foreach (@filename_list)
        {
                # Need explicit assignment to get a copy of $_ so that
                # shortening the contained prefix does not affect the list
                $current = $_;
                while ($current = shorten_prefix($current))
                {
                        $current .= "/";

                        # Skip rest if the remaining prefix has already been
                        # added to hash
                        if (exists($prefix{$current})) { last; }

                        # Initialize with 0
                        $prefix{$current}="0";
                }

        }

        # Remove all prefixes that would cause filenames to have less than
        # the minimum number of parent directories
        foreach my $filename (@filename_list) {
                my $dir = dirname($filename);

                for (my $i = 0; $i < $min_dir; $i++) {
                        delete($prefix{$dir."/"});
                        $dir = shorten_prefix($dir);
                }
        }

        # Check if any prefix remains
        return undef if (!%prefix);

        # Calculate sum of lengths for all prefixes
        foreach $current (keys(%prefix))
        {
                foreach (@filename_list)
                {
                        # Add original length
                        $prefix{$current} += length($_);

                        # Check whether prefix matches
                        if (substr($_, 0, length($current)) eq $current)
                        {
                                # Subtract prefix length for this filename
                                $prefix{$current} -= length($current);
                        }
                }
        }

        # Find and return prefix with minimal sum
        $current = (keys(%prefix))[0];

        foreach (keys(%prefix))
        {
                if ($prefix{$_} < $prefix{$current})
                {
                        $current = $_;
                }
        }

        $current =~ s/\/$//;

        return($current);
}


#
# shorten_prefix(prefix)
#
# Return PREFIX shortened by last directory component.
#

sub shorten_prefix($)
{
        my @list = split("/", $_[0]);

        pop(@list);
        return join("/", @list);
}



#
# get_dir_list(filename_list)
#
# Return sorted list of directories for each entry in given FILENAME_LIST.
#

sub get_dir_list(@)
{
        my %result;

        foreach (@_)
        {
                $result{shorten_prefix($_)} = "";
        }

        return(sort(keys(%result)));
}


#
# get_relative_base_path(subdirectory)
#
# Return a relative path string which references the base path when applied
# in SUBDIRECTORY.
#
# Example: get_relative_base_path("fs/mm") -> "../../"
#

sub get_relative_base_path($)
{
        my $result = "";
        my $index;

        # Make an empty directory path a special case
        if (!$_[0]) { return(""); }

        # Count number of /s in path
        $index = ($_[0] =~ s/\//\//g);

        # Add a ../ to $result for each / in the directory path + 1
        for (; $index>=0; $index--)
        {
                $result .= "../";
        }

        return $result;
}


#
# read_testfile(test_filename)
#
# Read in file TEST_FILENAME which contains test descriptions in the format:
#
#   TN:<whitespace><test name>
#   TD:<whitespace><test description>
#
# for each test case. Return a reference to a hash containing a mapping
#
#   test name -> test description.
#
# Die on error.
#

sub read_testfile($)
{
        my %result;
        my $test_name;
        my $changed_testname;
        local *TEST_HANDLE;

        open(TEST_HANDLE, "<", $_[0])
                or die("ERROR: cannot open $_[0]!\n");

        while (<TEST_HANDLE>)
        {
                chomp($_);

                # Match lines beginning with TN:<whitespace(s)>
                if (/^TN:\s+(.*?)\s*$/)
                {
                        # Store name for later use
                        $test_name = $1;
                        if ($test_name =~ s/\W/_/g)
                        {
                                $changed_testname = 1;
                        }
                }

                # Match lines beginning with TD:<whitespace(s)>
                if (/^TD:\s+(.*?)\s*$/)
                {
                        if (!defined($test_name)) {
                                die("ERROR: Found test description without prior test name in $_[0]:$.\n");
                        }
                        # Check for empty line
                        if ($1)
                        {
                                # Add description to hash
                                $result{$test_name} .= " $1";
                        }
                        else
                        {
                                # Add empty line
                                $result{$test_name} .= "\n\n";
                        }
                }
        }

        close(TEST_HANDLE);

        if ($changed_testname)
        {
                warn("WARNING: invalid characters removed from testname in ".
                     "descriptions file $_[0]\n");
        }

        return \%result;
}


#
# escape_html(STRING)
#
# Return a copy of STRING in which all occurrences of HTML special characters
# are escaped.
#

sub escape_html($)
{
        my $string = $_[0];

        if (!$string) { return ""; }

        $string =~ s/&/&amp;/g;         # & -> &amp;
        $string =~ s/</&lt;/g;          # < -> &lt;
        $string =~ s/>/&gt;/g;          # > -> &gt;
        $string =~ s/\"/&quot;/g;       # " -> &quot;

        while ($string =~ /^([^\t]*)(\t)/)
        {
                my $replacement = " "x($tab_size - (length($1) % $tab_size));
                $string =~ s/^([^\t]*)(\t)/$1$replacement/;
        }

        $string =~ s/\n/<br>/g;         # \n -> <br>

        return $string;
}


#
# get_date_string()
#
# Return the current date in the form: yyyy-mm-dd
#

sub get_date_string($)
{
  my $time = $_[0];
  my $year;
  my $month;
  my $day;
  my $hour;
  my $min;
  my $sec;
  my @timeresult;

  if (!$time) {
    if (defined $ENV{'SOURCE_DATE_EPOCH'})
    {
      @timeresult = gmtime($ENV{'SOURCE_DATE_EPOCH'});
    }
    else
    {
      @timeresult = localtime();
    }
  } else {
    @timeresult = localtime($time);
  }
  ($year, $month, $day, $hour, $min, $sec) = @timeresult[5, 4, 3, 2, 1, 0];

  return sprintf("%d-%02d-%02d %02d:%02d:%02d",
                 $year+1900, $month+1, $day, $hour, $min, $sec);
}


#
# create_sub_dir(dir_name)
#
# Create subdirectory DIR_NAME if it does not already exist, including all its
# parent directories.
#
# Die on error.
#

sub create_sub_dir($)
{
  my ($dir) = @_;

  system("mkdir", "-p" ,$dir)
    and die("ERROR: cannot create directory $dir!\n");
}


#
# write_description_file(descriptions, overall_found, overall_hit,
#                        total_fn_found, total_fn_hit, total_br_found,
#                        total_br_hit)
#
# Write HTML file containing all test case descriptions. DESCRIPTIONS is a
# reference to a hash containing a mapping
#
#   test case name -> test case description
#
# Die on error.
#

sub write_description_file($$)
{
  my %description = %{$_[0]};
  my $summary = $_[1];
  my $test_name;
  local *HTML_HANDLE;

  html_create(*HTML_HANDLE,"descriptions.$html_ext");
  write_html_prolog(*HTML_HANDLE, "", "LCOV - test case descriptions");
  write_header(*HTML_HANDLE, [3, 0], "", "", $summary, undef);

  write_test_table_prolog(*HTML_HANDLE,
                          "Test case descriptions - alphabetical list");

  foreach $test_name (sort(keys(%description))) {
    my $desc = $description{$test_name};

    $desc = escape_html($desc) if (!$rc_desc_html);
    write_test_table_entry(*HTML_HANDLE, $test_name, $desc);
  }

  write_test_table_epilog(*HTML_HANDLE);
  write_html_epilog(*HTML_HANDLE, "");

  close(*HTML_HANDLE);
}



#
# write_png_files()
#
# Create all necessary .png files for the HTML-output in the current
# directory. .png-files are used as bar graphs.
#
# Die on error.
#

sub write_png_files()
{
  my %data;
  local *PNG_HANDLE;

  $data{"ruby.png"} =
      [0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00,
       0x00, 0x0d, 0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x01,
       0x00, 0x00, 0x00, 0x01, 0x01, 0x03, 0x00, 0x00, 0x00, 0x25,
       0xdb, 0x56, 0xca, 0x00, 0x00, 0x00, 0x07, 0x74, 0x49, 0x4d,
       0x45, 0x07, 0xd2, 0x07, 0x11, 0x0f, 0x18, 0x10, 0x5d, 0x57,
       0x34, 0x6e, 0x00, 0x00, 0x00, 0x09, 0x70, 0x48, 0x59, 0x73,
       0x00, 0x00, 0x0b, 0x12, 0x00, 0x00, 0x0b, 0x12, 0x01, 0xd2,
       0xdd, 0x7e, 0xfc, 0x00, 0x00, 0x00, 0x04, 0x67, 0x41, 0x4d,
       0x41, 0x00, 0x00, 0xb1, 0x8f, 0x0b, 0xfc, 0x61, 0x05, 0x00,
       0x00, 0x00, 0x06, 0x50, 0x4c, 0x54, 0x45, 0xff, 0x35, 0x2f,
       0x00, 0x00, 0x00, 0xd0, 0x33, 0x9a, 0x9d, 0x00, 0x00, 0x00,
       0x0a, 0x49, 0x44, 0x41, 0x54, 0x78, 0xda, 0x63, 0x60, 0x00,
       0x00, 0x00, 0x02, 0x00, 0x01, 0xe5, 0x27, 0xde, 0xfc, 0x00,
       0x00, 0x00, 0x00, 0x49, 0x45, 0x4e, 0x44, 0xae, 0x42, 0x60,
       0x82];
  $data{"amber.png"} =
      [0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00,
       0x00, 0x0d, 0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x01,
       0x00, 0x00, 0x00, 0x01, 0x01, 0x03, 0x00, 0x00, 0x00, 0x25,
       0xdb, 0x56, 0xca, 0x00, 0x00, 0x00, 0x07, 0x74, 0x49, 0x4d,
       0x45, 0x07, 0xd2, 0x07, 0x11, 0x0f, 0x28, 0x04, 0x98, 0xcb,
       0xd6, 0xe0, 0x00, 0x00, 0x00, 0x09, 0x70, 0x48, 0x59, 0x73,
       0x00, 0x00, 0x0b, 0x12, 0x00, 0x00, 0x0b, 0x12, 0x01, 0xd2,
       0xdd, 0x7e, 0xfc, 0x00, 0x00, 0x00, 0x04, 0x67, 0x41, 0x4d,
       0x41, 0x00, 0x00, 0xb1, 0x8f, 0x0b, 0xfc, 0x61, 0x05, 0x00,
       0x00, 0x00, 0x06, 0x50, 0x4c, 0x54, 0x45, 0xff, 0xe0, 0x50,
       0x00, 0x00, 0x00, 0xa2, 0x7a, 0xda, 0x7e, 0x00, 0x00, 0x00,
       0x0a, 0x49, 0x44, 0x41, 0x54, 0x78, 0xda, 0x63, 0x60, 0x00,
       0x00, 0x00, 0x02, 0x00, 0x01, 0xe5, 0x27, 0xde, 0xfc, 0x00,
       0x00, 0x00, 0x00, 0x49, 0x45, 0x4e, 0x44, 0xae, 0x42, 0x60,
       0x82];
  $data{"emerald.png"} =
      [0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00,
       0x00, 0x0d, 0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x01,
       0x00, 0x00, 0x00, 0x01, 0x01, 0x03, 0x00, 0x00, 0x00, 0x25,
       0xdb, 0x56, 0xca, 0x00, 0x00, 0x00, 0x07, 0x74, 0x49, 0x4d,
       0x45, 0x07, 0xd2, 0x07, 0x11, 0x0f, 0x22, 0x2b, 0xc9, 0xf5,
       0x03, 0x33, 0x00, 0x00, 0x00, 0x09, 0x70, 0x48, 0x59, 0x73,
       0x00, 0x00, 0x0b, 0x12, 0x00, 0x00, 0x0b, 0x12, 0x01, 0xd2,
       0xdd, 0x7e, 0xfc, 0x00, 0x00, 0x00, 0x04, 0x67, 0x41, 0x4d,
       0x41, 0x00, 0x00, 0xb1, 0x8f, 0x0b, 0xfc, 0x61, 0x05, 0x00,
       0x00, 0x00, 0x06, 0x50, 0x4c, 0x54, 0x45, 0x1b, 0xea, 0x59,
       0x0a, 0x0a, 0x0a, 0x0f, 0xba, 0x50, 0x83, 0x00, 0x00, 0x00,
       0x0a, 0x49, 0x44, 0x41, 0x54, 0x78, 0xda, 0x63, 0x60, 0x00,
       0x00, 0x00, 0x02, 0x00, 0x01, 0xe5, 0x27, 0xde, 0xfc, 0x00,
       0x00, 0x00, 0x00, 0x49, 0x45, 0x4e, 0x44, 0xae, 0x42, 0x60,
       0x82];
  $data{"snow.png"} =
      [0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00,
       0x00, 0x0d, 0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x01,
       0x00, 0x00, 0x00, 0x01, 0x01, 0x03, 0x00, 0x00, 0x00, 0x25,
       0xdb, 0x56, 0xca, 0x00, 0x00, 0x00, 0x07, 0x74, 0x49, 0x4d,
       0x45, 0x07, 0xd2, 0x07, 0x11, 0x0f, 0x1e, 0x1d, 0x75, 0xbc,
       0xef, 0x55, 0x00, 0x00, 0x00, 0x09, 0x70, 0x48, 0x59, 0x73,
       0x00, 0x00, 0x0b, 0x12, 0x00, 0x00, 0x0b, 0x12, 0x01, 0xd2,
       0xdd, 0x7e, 0xfc, 0x00, 0x00, 0x00, 0x04, 0x67, 0x41, 0x4d,
       0x41, 0x00, 0x00, 0xb1, 0x8f, 0x0b, 0xfc, 0x61, 0x05, 0x00,
       0x00, 0x00, 0x06, 0x50, 0x4c, 0x54, 0x45, 0xff, 0xff, 0xff,
       0x00, 0x00, 0x00, 0x55, 0xc2, 0xd3, 0x7e, 0x00, 0x00, 0x00,
       0x0a, 0x49, 0x44, 0x41, 0x54, 0x78, 0xda, 0x63, 0x60, 0x00,
       0x00, 0x00, 0x02, 0x00, 0x01, 0xe5, 0x27, 0xde, 0xfc, 0x00,
       0x00, 0x00, 0x00, 0x49, 0x45, 0x4e, 0x44, 0xae, 0x42, 0x60,
       0x82];
  $data{"glass.png"} =
      [0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00,
       0x00, 0x0d, 0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x01,
       0x00, 0x00, 0x00, 0x01, 0x01, 0x03, 0x00, 0x00, 0x00, 0x25,
       0xdb, 0x56, 0xca, 0x00, 0x00, 0x00, 0x04, 0x67, 0x41, 0x4d,
       0x41, 0x00, 0x00, 0xb1, 0x8f, 0x0b, 0xfc, 0x61, 0x05, 0x00,
       0x00, 0x00, 0x06, 0x50, 0x4c, 0x54, 0x45, 0xff, 0xff, 0xff,
       0x00, 0x00, 0x00, 0x55, 0xc2, 0xd3, 0x7e, 0x00, 0x00, 0x00,
       0x01, 0x74, 0x52, 0x4e, 0x53, 0x00, 0x40, 0xe6, 0xd8, 0x66,
       0x00, 0x00, 0x00, 0x01, 0x62, 0x4b, 0x47, 0x44, 0x00, 0x88,
       0x05, 0x1d, 0x48, 0x00, 0x00, 0x00, 0x09, 0x70, 0x48, 0x59,
       0x73, 0x00, 0x00, 0x0b, 0x12, 0x00, 0x00, 0x0b, 0x12, 0x01,
       0xd2, 0xdd, 0x7e, 0xfc, 0x00, 0x00, 0x00, 0x07, 0x74, 0x49,
       0x4d, 0x45, 0x07, 0xd2, 0x07, 0x13, 0x0f, 0x08, 0x19, 0xc4,
       0x40, 0x56, 0x10, 0x00, 0x00, 0x00, 0x0a, 0x49, 0x44, 0x41,
       0x54, 0x78, 0x9c, 0x63, 0x60, 0x00, 0x00, 0x00, 0x02, 0x00,
       0x01, 0x48, 0xaf, 0xa4, 0x71, 0x00, 0x00, 0x00, 0x00, 0x49,
       0x45, 0x4e, 0x44, 0xae, 0x42, 0x60, 0x82];
  $data{"updown.png"} =
      [0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00,
       0x00, 0x0d, 0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x0a,
       0x00, 0x00, 0x00, 0x0e, 0x08, 0x06, 0x00, 0x00, 0x00, 0x16,
       0xa3, 0x8d, 0xab, 0x00, 0x00, 0x00, 0x3c, 0x49, 0x44, 0x41,
       0x54, 0x28, 0xcf, 0x63, 0x60, 0x40, 0x03, 0xff, 0xa1, 0x00,
       0x5d, 0x9c, 0x11, 0x5d, 0x11, 0x8a, 0x24, 0x23, 0x23, 0x23,
       0x86, 0x42, 0x6c, 0xa6, 0x20, 0x2b, 0x66, 0xc4, 0xa7, 0x08,
       0x59, 0x31, 0x23, 0x21, 0x45, 0x30, 0xc0, 0xc4, 0x30, 0x60,
       0x80, 0xfa, 0x6e, 0x24, 0x3e, 0x78, 0x48, 0x0a, 0x70, 0x62,
       0xa2, 0x90, 0x81, 0xd8, 0x44, 0x01, 0x00, 0xe9, 0x5c, 0x2f,
       0xf5, 0xe2, 0x9d, 0x0f, 0xf9, 0x00, 0x00, 0x00, 0x00, 0x49,
       0x45, 0x4e, 0x44, 0xae, 0x42, 0x60, 0x82] if ($sort);
  foreach (keys(%data))
  {
    open(PNG_HANDLE, ">", $_)
        or die("ERROR: cannot create $_!\n");
    binmode(PNG_HANDLE);
    print(PNG_HANDLE map(chr,@{$data{$_}}));
    close(PNG_HANDLE);
  }
}


#
# write_htaccess_file()
#

sub write_htaccess_file()
{
        local *HTACCESS_HANDLE;
        my $htaccess_data;

        open(*HTACCESS_HANDLE, ">", ".htaccess")
                or die("ERROR: cannot open .htaccess for writing!\n");

        $htaccess_data = (<<"END_OF_HTACCESS")
AddEncoding x-gzip .html
END_OF_HTACCESS
        ;

        print(HTACCESS_HANDLE $htaccess_data);
        close(*HTACCESS_HANDLE);
}


#
# write_css_file()
#
# Write the cascading style sheet file gcov.css to the current directory.
# This file defines basic layout attributes of all generated HTML pages.
#

sub write_css_file()
{
  local *CSS_HANDLE;

  # Check for a specified external style sheet file
  if ($css_filename)
  {
    # Simply copy that file
      system("cp", $css_filename, "gcov.css")
          and die("ERROR: cannot copy file $css_filename!\n");
      return;
  }

  open(CSS_HANDLE, ">", "gcov.css")
      or die ("ERROR: cannot open gcov.css for writing!\n");


  # *************************************************************
  my $ownerBackground = "#E5DBDB"; # very light pale grey/blue
  my $ownerCovHi = "#82E0AA"; # light green
  my $ownerCovMed = "#F9E79F"; # light yellow
  my $ownerCovLo = "#EC7063"; # lighter red
  my $css_data = ($_=<<"END_OF_CSS")
        /* All views: initial background and text color */
        body
        {
          color: #000000;
          background-color: #FFFFFF;
        }

        /* All views: standard link format*/
        a:link
        {
          color: #284FA8;
          text-decoration: underline;
        }

        /* All views: standard link - visited format */
        a:visited
        {
          color: #00CB40;
          text-decoration: underline;
        }

        /* All views: standard link - activated format */
        a:active
        {
          color: #FF0040;
          text-decoration: underline;
        }

        /* All views: main title format */
        td.title
        {
          text-align: center;
          padding-bottom: 10px;
          font-family: sans-serif;
          font-size: 20pt;
          font-style: italic;
          font-weight: bold;
        }
        /* 'Line coverage date bins" leader */
        td.subTableHeader
        {
          text-align: center;
          padding-bottom: 6px;
          font-family: sans-serif;
          font-weight: bold;
          vertical-align: center;
        }

        /* All views: header item format */
        td.headerItem
        {
          text-align: right;
          padding-right: 6px;
          font-family: sans-serif;
          font-weight: bold;
          vertical-align: top;
          white-space: nowrap;
        }

        /* All views: header item value format */
        td.headerValue
        {
          text-align: left;
          color: #284FA8;
          font-family: sans-serif;
          font-weight: bold;
          white-space: nowrap;
        }

        /* All views: header item coverage table heading */
        td.headerCovTableHead
        {
          text-align: center;
          padding-right: 6px;
          padding-left: 6px;
          padding-bottom: 0px;
          font-family: sans-serif;
          font-size: 80%;
          white-space: nowrap;
        }

        /* All views: header item coverage table entry */
        td.headerCovTableEntry
        {
          text-align: right;
          color: #284FA8;
          font-family: sans-serif;
          font-weight: bold;
          white-space: nowrap;
          padding-left: 12px;
          padding-right: 4px;
          background-color: #DAE7FE;
        }

        /* All views: header item coverage table entry for high coverage rate */
        td.headerCovTableEntryHi
        {
          text-align: right;
          color: #000000;
          font-family: sans-serif;
          font-weight: bold;
          white-space: nowrap;
          padding-left: 12px;
          padding-right: 4px;
          background-color: #A7FC9D;
        }

        /* All views: header item coverage table entry for medium coverage rate */
        td.headerCovTableEntryMed
        {
          text-align: right;
          color: #000000;
          font-family: sans-serif;
          font-weight: bold;
          white-space: nowrap;
          padding-left: 12px;
          padding-right: 4px;
          background-color: #FFEA20;
        }

        /* All views: header item coverage table entry for ow coverage rate */
        td.headerCovTableEntryLo
        {
          text-align: right;
          color: #000000;
          font-family: sans-serif;
          font-weight: bold;
          white-space: nowrap;
          padding-left: 12px;
          padding-right: 4px;
          background-color: #FF0000;
        }

        /* All views: header legend value for legend entry */
        td.headerValueLeg
        {
          text-align: left;
          color: #000000;
          font-family: sans-serif;
          font-size: 80%;
          white-space: nowrap;
          padding-top: 4px;
        }

        /* All views: color of horizontal ruler */
        td.ruler
        {
          background-color: #6688D4;
        }

        /* All views: version string format */
        td.versionInfo
        {
          text-align: center;
          padding-top: 2px;
          font-family: sans-serif;
          font-style: italic;
        }

        /* Directory view/File view (all)/Test case descriptions:
           table headline format */
        td.tableHead
        {
          text-align: center;
          color: #FFFFFF;
          background-color: #6688D4;
          font-family: sans-serif;
          font-size: 120%;
          font-weight: bold;
          white-space: nowrap;
          padding-left: 4px;
          padding-right: 4px;
        }

        span.tableHeadSort
        {
          padding-right: 4px;
        }

        /* Directory view/File view (all): filename entry format */
        td.coverFile
        {
          text-align: left;
          padding-left: 10px;
          padding-right: 20px;
          color: #284FA8;
          background-color: #DAE7FE;
          font-family: monospace;
        }

        /* Directory view/File view (all): filename entry format */
        td.overallOwner
        {
          text-align: center;
          font-style: bold;
          font-family: sans-serif;
          background-color: #DAE7FE;
          padding-right: 10px;
          padding-left: 10px;
        }

        /* Directory view/File view (all): filename entry format */
        td.ownerName
        {
          text-align: right;
          font-style: italic;
          font-family: sans-serif;
          background-color: $ownerBackground;
          padding-right: 10px;
          padding-left: 20px;
        }

        /* Directory view/File view (all): bar-graph entry format*/
        td.coverBar
        {
          padding-left: 10px;
          padding-right: 10px;
          background-color: #DAE7FE;
        }

        /* Directory view/File view (all): bar-graph entry format*/
        td.owner_coverBar
        {
          padding-left: 10px;
          padding-right: 10px;
          background-color: $ownerBackground;
        }

        /* Directory view/File view (all): bar-graph outline color */
        td.coverBarOutline
        {
          background-color: #000000;
        }

        /* Directory view/File view (all): percentage entry for files with
           high coverage rate */
        td.coverPerHi
        {
          text-align: right;
          padding-left: 10px;
          padding-right: 10px;
          background-color: #A7FC9D;
          font-weight: bold;
          font-family: sans-serif;
        }

        /* 'owner' entry:  slightly lighter color than 'coverPerHi' */
        td.owner_coverPerHi
        {
          text-align: right;
          padding-left: 10px;
          padding-right: 10px;
          background-color: $ownerCovHi;
          font-weight: bold;
          font-family: sans-serif;
        }

        /* Directory view/File view (all): line count entry */
        td.coverNumDflt
        {
          text-align: right;
          padding-left: 10px;
          padding-right: 10px;
          background-color: #DAE7FE;
          white-space: nowrap;
          font-family: sans-serif;
        }

        /* td background color and font for 'the 'owner' section of the table */
        td.ownerTla
        {
          text-align: right;
          padding-left: 10px;
          padding-right: 10px;
          background-color: $ownerBackground;
          white-space: nowrap;
          font-family: sans-serif;
          font-style: italic;
        }

        /* Directory view/File view (all): line count entry for files with
           high coverage rate */
        td.coverNumHi
        {
          text-align: right;
          padding-left: 10px;
          padding-right: 10px;
          background-color: #A7FC9D;
          white-space: nowrap;
          font-family: sans-serif;
        }

        td.owner_coverNumHi
        {
          text-align: right;
          padding-left: 10px;
          padding-right: 10px;
          background-color: $ownerCovHi;
          white-space: nowrap;
          font-family: sans-serif;
        }

        /* Directory view/File view (all): percentage entry for files with
           medium coverage rate */
        td.coverPerMed
        {
          text-align: right;
          padding-left: 10px;
          padding-right: 10px;
          background-color: #FFEA20;
          font-weight: bold;
          font-family: sans-serif;
        }

        td.owner_coverPerMed
        {
          text-align: right;
          padding-left: 10px;
          padding-right: 10px;
          background-color: $ownerCovMed;
          font-weight: bold;
          font-family: sans-serif;
        }

        /* Directory view/File view (all): line count entry for files with
           medium coverage rate */
        td.coverNumMed
        {
          text-align: right;
          padding-left: 10px;
          padding-right: 10px;
          background-color: #FFEA20;
          white-space: nowrap;
          font-family: sans-serif;
        }

        td.owner_coverNumMed
        {
          text-align: right;
          padding-left: 10px;
          padding-right: 10px;
          background-color: $ownerCovMed;
          white-space: nowrap;
          font-family: sans-serif;
        }

        /* Directory view/File view (all): percentage entry for files with
           low coverage rate */
        td.coverPerLo
        {
          text-align: right;
          padding-left: 10px;
          padding-right: 10px;
          background-color: #FF0000;
          font-weight: bold;
          font-family: sans-serif;
        }

        td.owner_coverPerLo
        {
          text-align: right;
          padding-left: 10px;
          padding-right: 10px;
          background-color: $ownerCovLo;
          font-weight: bold;
          font-family: sans-serif;
        }

        /* Directory view/File view (all): line count entry for files with
           low coverage rate */
        td.coverNumLo
        {
          text-align: right;
          padding-left: 10px;
          padding-right: 10px;
          background-color: #FF0000;
          white-space: nowrap;
          font-family: sans-serif;
        }

        td.owner_coverNumLo
        {
          text-align: right;
          padding-left: 10px;
          padding-right: 10px;
          background-color: $ownerCovLo;
          white-space: nowrap;
          font-family: sans-serif;
        }

        /* File view (all): "show/hide details" link format */
        a.detail:link
        {
          color: #B8D0FF;
          font-size:80%;
        }

        /* File view (all): "show/hide details" link - visited format */
        a.detail:visited
        {
          color: #B8D0FF;
          font-size:80%;
        }

        /* File view (all): "show/hide details" link - activated format */
        a.detail:active
        {
          color: #FFFFFF;
          font-size:80%;
        }

        /* File view (detail): test name entry */
        td.testName
        {
          text-align: right;
          padding-right: 10px;
          background-color: #DAE7FE;
          font-family: sans-serif;
        }

        /* File view (detail): test percentage entry */
        td.testPer
        {
          text-align: right;
          padding-left: 10px;
          padding-right: 10px;
          background-color: #DAE7FE;
          font-family: sans-serif;
        }

        /* File view (detail): test lines count entry */
        td.testNum
        {
          text-align: right;
          padding-left: 10px;
          padding-right: 10px;
          background-color: #DAE7FE;
          font-family: sans-serif;
        }

        /* Test case descriptions: test name format*/
        dt
        {
          font-family: sans-serif;
          font-weight: bold;
        }

        /* Test case descriptions: description table body */
        td.testDescription
        {
          padding-top: 10px;
          padding-left: 30px;
          padding-bottom: 10px;
          padding-right: 30px;
          background-color: #DAE7FE;
        }

        /* Source code view: function entry */
        td.coverFn
        {
          text-align: left;
          padding-left: 10px;
          padding-right: 20px;
          color: #284FA8;
          background-color: #DAE7FE;
          font-family: monospace;
        }

        /* Source code view: function entry zero count*/
        td.coverFnLo
        {
          text-align: right;
          padding-left: 10px;
          padding-right: 10px;
          background-color: #FF0000;
          font-weight: bold;
          font-family: sans-serif;
        }

        /* Source code view: function entry nonzero count*/
        td.coverFnHi
        {
          text-align: right;
          padding-left: 10px;
          padding-right: 10px;
          background-color: #DAE7FE;
          font-weight: bold;
          font-family: sans-serif;
        }

        /* Source code view: source code format */
        pre.source
        {
          font-family: monospace;
          white-space: pre;
          margin-top: 2px;
        }

        /* Source code view: line number format */
        span.lineNum
        {
          background-color: #EFE383;
        }

        /* Source code view: format for Cov legend */
        span.coverLegendCov
        {
          padding-left: 10px;
          padding-right: 10px;
          padding-bottom: 2px;
          background-color: #CAD7FE;
        }

        /* Source code view: format for NoCov legend */
        span.coverLegendNoCov
        {
          padding-left: 10px;
          padding-right: 10px;
          padding-bottom: 2px;
          background-color: #FF6230;
        }

        /* Source code view: format for the source code heading line */
        pre.sourceHeading
        {
          white-space: pre;
          font-family: monospace;
          font-weight: bold;
          margin: 0px;
        }

        /* All views: header legend value for low rate */
        td.headerValueLegL
        {
          font-family: sans-serif;
          text-align: center;
          white-space: nowrap;
          padding-left: 4px;
          padding-right: 2px;
          background-color: #FF0000;
          font-size: 80%;
        }

        /* All views: header legend value for med rate */
        td.headerValueLegM
        {
          font-family: sans-serif;
          text-align: center;
          white-space: nowrap;
          padding-left: 2px;
          padding-right: 2px;
          background-color: #FFEA20;
          font-size: 80%;
        }

        /* All views: header legend value for hi rate */
        td.headerValueLegH
        {
          font-family: sans-serif;
          text-align: center;
          white-space: nowrap;
          padding-left: 2px;
          padding-right: 4px;
          background-color: #A7FC9D;
          font-size: 80%;
        }

        /* All views except source code view: legend format for low coverage */
        span.coverLegendCovLo
        {
          padding-left: 10px;
          padding-right: 10px;
          padding-top: 2px;
          background-color: #FF0000;
        }

        /* All views except source code view: legend format for med coverage */
        span.coverLegendCovMed
        {
          padding-left: 10px;
          padding-right: 10px;
          padding-top: 2px;
          background-color: #FFEA20;
        }

        /* All views except source code view: legend format for hi coverage */
        span.coverLegendCovHi
        {
          padding-left: 10px;
          padding-right: 10px;
          padding-top: 2px;
          background-color: #A7FC9D;
        }

END_OF_CSS
      ;

  # 'span' tags for all the TLA's
  foreach my $tla (@SummaryInfo::tlaPriorityOrder) {
    my $title = $SummaryInfo::tlaToTitle{$tla};
    my $color = $SummaryInfo::tlaColor{$tla};
    foreach my $elem ("td", "span") {
      my $align = $elem eq 'td' ? "right" : "left";
      $css_data .= ($_=<<"END_OF_SPAN")

        /* Source code view/table entry backround: format for lines classified as "$title" */
        $elem.tla$tla
        {
          text-align: $align;
          background-color: $color
        }
END_OF_SPAN
          ;
    }
  }

  # 'span' tags for date bins...
  #   probably should have one for each bin...
  $css_data .= ($_=<<"END_OF_DATE_SPAN")

        /* Source code view: format for date/owner bin that isn't hit */
        span.missBins
        {
          background-color: #FF0000 /* red */
        }
END_OF_DATE_SPAN
      ;

  # *************************************************************

  # Remove leading tab from all lines
  $css_data =~ s/^\t//gm;
  $css_data =~ s/^        //gm;

  print(CSS_HANDLE $css_data);

  close(CSS_HANDLE);
}


#
# get_bar_graph_code(base_dir, cover_found, cover_hit)
#
# Return a string containing HTML code which implements a bar graph display
# for a coverage rate of cover_hit * 100 / cover_found.
#

sub get_bar_graph_code($$$)
{
  my ($base_dir, $found, $hit) = @_;
  my $rate;
  my $alt;
  my $width;
  my $remainder;
  my $png_name;
  my $graph_code;

  # Check number of instrumented lines
  if ($_[1] == 0) { return ""; }

  $alt            = rate($hit, $found, "%");
  $width          = rate($hit, $found, undef, 0);
  $remainder      = 100 - $width;

  # Decide which .png file to use
  $png_name = $rate_png[classify_rate($found, $hit, $med_limit, $hi_limit)];

  if ($width == 0)
  {
    # Zero coverage
    $graph_code = (<<END_OF_HTML);
                <table border=0 cellspacing=0 cellpadding=1><tr><td class="coverBarOutline"><img src="$_[0]snow.png" width=100 height=10 alt="$alt"></td></tr></table>
END_OF_HTML
  }
  elsif ($width == 100)
  {
    # Full coverage
    $graph_code = (<<END_OF_HTML);
                <table border=0 cellspacing=0 cellpadding=1><tr><td class="coverBarOutline"><img src="$_[0]$png_name" width=100 height=10 alt="$alt"></td></tr></table>
END_OF_HTML
  }
  else
  {
    # Positive coverage
    $graph_code = (<<END_OF_HTML);
                <table border=0 cellspacing=0 cellpadding=1><tr><td class="coverBarOutline"><img src="$_[0]$png_name" width=$width height=10 alt="$alt"><img src="$_[0]snow.png" width=$remainder height=10 alt="$alt"></td></tr></table>
END_OF_HTML
  }

  # Remove leading tabs from all lines
  $graph_code =~ s/^\t+//gm;
  chomp($graph_code);

  return($graph_code);
}

#
# sub classify_rate(found, hit, med_limit, high_limit)
#
# Return 0 for low rate, 1 for medium rate and 2 for hi rate.
#

sub classify_rate($$$$)
{
        my ($found, $hit, $med, $hi) = @_;
        my $rate;

        if ($found == 0) {
                return 2;
        }
        $rate = rate($hit, $found);
        if ($rate < $med) {
                return 0;
        } elsif ($rate < $hi) {
                return 1;
        }
        return 2;
}


#
# write_html(filehandle, html_code)
#
# Write out HTML_CODE to FILEHANDLE while removing a leading tabulator mark
# in each line of HTML_CODE.
#

sub write_html(*$)
{
  local *HTML_HANDLE = $_[0];
  my $html_code = $_[1];

  # Remove leading tab from all lines
  $html_code =~ s/^\t//gm;

  print(HTML_HANDLE $html_code)
      or die("ERROR: cannot write HTML data ($!)\n");
}


#
# write_html_prolog(filehandle, base_dir, pagetitle)
#
# Write an HTML prolog common to all HTML files to FILEHANDLE. PAGETITLE will
# be used as HTML page title. BASE_DIR contains a relative path which points
# to the base directory.
#

sub write_html_prolog(*$$)
{
  my $basedir = $_[1];
  my $pagetitle = $_[2];
  my $prolog;

  $prolog = $html_prolog;
  $prolog =~ s/\@pagetitle\@/$pagetitle/g;
  $prolog =~ s/\@basedir\@/$basedir/g;

  write_html($_[0], $prolog);
}


#
# write_header_prolog(filehandle, base_dir)
#
# Write beginning of page header HTML code.
#

sub write_header_prolog(*$)
{
  # *************************************************************

  write_html($_[0], <<END_OF_HTML);
          <table width="100%" border=0 cellspacing=0 cellpadding=0>
            <tr><td class="title">$title</td></tr>
            <tr><td class="ruler"><img src="$_[1]glass.png" width=3 height=3 alt=""></td></tr>

            <tr>
              <td width="100%">
                <table cellpadding=1 border=0 width="100%">
END_OF_HTML

  # *************************************************************
}


#
# write_header_line(handle, content)
#
# Write a header line with the specified table contents.
#

sub write_header_line(*@)
{
  my ($handle, @content) = @_;

  write_html($handle, "          <tr>\n");
  foreach my $entry (@content) {
    my ($width, $class, $text, $colspan) = @{$entry};

    if (defined($width)) {
      $width = " width=\"$width\"";
    } else {
      $width = "";
    }
    if (defined($class)) {
      $class = " class=\"$class\"";
    } else {
      $class = "";
    }
    if (defined($colspan)) {
      $colspan = " colspan=\"$colspan\"";
    } else {
      $colspan = "";
    }
    $text = "" if (!defined($text));
    write_html($handle,
               "            <td$width$class$colspan>$text</td>\n");
  }
  write_html($handle, "          </tr>\n");
}


#
# write_header_epilog(filehandle, base_dir)
#
# Write end of page header HTML code.
#

sub write_header_epilog(*$)
{
  # *************************************************************

  write_html($_[0], <<END_OF_HTML);
                  <tr><td><img src="$_[1]glass.png" width=3 height=3 alt=""></td></tr>
                </table>
              </td>
            </tr>

            <tr><td class="ruler"><img src="$_[1]glass.png" width=3 height=3 alt=""></td></tr>
          </table>

END_OF_HTML

  # *************************************************************
}


#
# write_file_table_prolog(handle, file_heading, binHeading, ([heading, num_cols], ...))
#
# Write heading for file table.
#

sub write_file_table_prolog(*$$@)
{
  my ($handle, $file_heading, $bin_heading, @columns) = @_;
  my $num_columns = 0;
  my $file_width;
  my $col;
  my $width;

  $width = 20 if (scalar(@columns) == 1);
  $width = 10 if (scalar(@columns) == 2);
  $width = 8 if (scalar(@columns) > 2);

  foreach $col (@columns) {
    my ($heading, $cols, $titles) = @{$col};
    if ($titles) {
      $num_columns += scalar(@$titles);
    } else {
      $num_columns += $cols;
    }
  }
  $file_width = 100 - $num_columns * $width;

  # Table definition
  write_html($handle, <<END_OF_HTML);
          <center>
          <table width="80%" cellpadding=1 cellspacing=1 border=0>

            <tr>
              <td width="$file_width%"><br></td>
END_OF_HTML
  if (defined($bin_heading)) {
    # owner or date column
    write_html($handle, <<END_OF_HTML);
              <td width=15</td>
END_OF_HTML
  }
  # Empty first row
  foreach $col (@columns) {
    my ($heading, $cols) = @{$col};

    while ($cols-- > 0) {
      write_html($handle, <<END_OF_HTML);
            <td width="$width%"></td>
END_OF_HTML
    }
  }
  # Next row
  my $spanType = defined($bin_heading) ? "colspan" : "rowspan";
  write_html($handle, <<END_OF_HTML);
            </tr>

            <tr>
              <td class="tableHead" $spanType=2>$file_heading</td>
END_OF_HTML
  # Heading row
  foreach $col (@columns) {
    my ($heading, $cols, $titles) = @{$col};
    my $colspan = "";
    my $rowspan = "";
    $colspan = " colspan=$cols" if ($cols > 1);
    $rowspan = " rowspan=2" if (!defined($titles));
    write_html($handle, <<END_OF_HTML);
        <td class="tableHead"$colspan$rowspan>$heading</td>
END_OF_HTML
  }
  write_html($handle, <<END_OF_HTML);
            </tr>
            <tr>
END_OF_HTML

  # title row
  if (defined($bin_heading)) {
    # Next row
    write_html($handle, <<END_OF_HTML);
              <td class="tableHead">Name</td>
              <td class="tableHead">$bin_heading</td>
END_OF_HTML
  }
  foreach $col (@columns) {
    my ($heading, $cols, $titles) = @{$col};
    my $colspan = "";
    my $rowspan = "";

    if (defined($titles)) {
      foreach my $t (@$titles) {
        my $span = "";
        if ("ARRAY" eq ref($t)) {
          $span = " colspan=" . $t->[1];
          $t = $t->[0];
        }
        write_html($handle, <<END_OF_HTML);
                    <td class="tableHead"$span> $t</td>
END_OF_HTML
      }
    }
  }
  write_html($handle, <<END_OF_HTML);
            </tr>
END_OF_HTML
}


# write_file_table_entry(handle, base_dir,
#                        [name, [filenameame, fileDetails, fileHref],
#                         rowspan, page_type,
#                         page_link, dirSummary, showDetailColumn, callback,
#                         covType ],
#                        ([ found, hit, med_limit, hi_limit, graph ], ..)
#
# Write an entry of the file table.
#

sub write_file_table_entry(*$$@)
{
  my ($handle, $base_dir, $data, @entries) = @_;
  my ($name, $callbackData, $rowspan, $page_type, $page_link,
      $dirSummary, $showBinDetailColumn) = @$data;
  my $namecode;
  my $entry;
  my $esc_name = escape_html($name);
  my $owner;
  # Add link to source if provided
  if ($page_type eq "fileOrDir" &&
      defined($page_link) && $page_link ne "") {
    $namecode = "<a href=\"$page_link\">$esc_name</a>";
    $owner = "";
  }
  else {
    $namecode = $esc_name;
  }
  my ($filename, $fileDetails, $file_link) = @$callbackData;
  my $tableHref;
  if (defined($file_link)) {
    if ($main::frames) {
      # href to anchor in frame doesnt seem to work in either firefox
      #   or chrome.  However, this seems like the right syntax.
      $tableHref .= "href=\"$file_link#__LINE__\" target=\"source\""
	if 0;
    } else {
      $tableHref = "href=\"$file_link#__LINE__\"";
    }
  }
  # First column: name
  my ($nameClass, $prefix);
  if ('owner' eq $page_type ||
      'date' eq $page_type) {
    $nameClass = "ownerName";
    $prefix = "owner_";
  } else {
    $nameClass = 'coverFile';
    $prefix = "";
  }
  my $span = (1 == $rowspan) ? "" : " rowspan=$rowspan";
  write_html($handle, <<END_OF_HTML);
            <tr>
              <td class="$nameClass"$span>$namecode</td>
END_OF_HTML

  # no 'owner' column if the entire directory is not part of the project
  #  (i.e., no files in this directory are in the repo)
  if (defined($showBinDetailColumn) &&
      $dirSummary->hasOwnerInfo()) {
      write_html($handle, <<END_OF_HTML);
              <td class="overallOwner">Total</td>
END_OF_HTML
  }
  foreach $entry (@entries) {
    my ($found, $hit, $med, $hi, $graph, $summary, $covType) = @{$entry};
    my $bar_graph;
    my $class;
    my $rate;

    # Generate bar graph if requested
    if ($graph) {
      $bar_graph = get_bar_graph_code($base_dir, $found, $hit);
            write_html($handle, <<END_OF_HTML);
              <td class="${prefix}coverBar" align="center">
                $bar_graph
              </td>
END_OF_HTML
    }
    # Get rate color and text
    if ($found == 0) {
      $rate = "-";
      $class = "Hi";
    } else {
      $rate = rate($hit, $found, "&nbsp;%");
      $class = $rate_name[classify_rate($found, $hit, $med, $hi)];
    }
    if ($opt_missed) {
      # Show negative number of items without coverage
        $hit = -($found - $hit);
    }
    write_html($handle, <<END_OF_HTML);
              <td class="${prefix}coverPer$class">$rate</td>
END_OF_HTML
    if ($summary) {
      my @keys = ("found", $opt_missed ? "not_hit" : "hit");
      if ($main::show_tla) {
        push(@keys, @SummaryInfo::tlaPriorityOrder);
      }
      foreach my $key (@keys) {
        my $count = $summary->get($key);
        #print("$name: $key " . $summary->get($key));
        $class = $page_type ne "owner" ? "coverNumDflt" : "ownerTla";
        my $v = "";
        if ( defined($count) && 0 != $count ) {
          $v = $count;
          # want to colorize the UNC, LBC, UIC rows if not zero
          $class = "tla$key" if grep(/^$key$/, ("UNC", "LBC", "UIC"));

          # want to look in file details to build link to first
          #   line...
          if (defined($tableHref) &&
              defined($fileDetails) &&
              'D' ne substr($key,0,1) &&
              grep(/^$key$/, @SummaryInfo::tlaPriorityOrder)) {
            my $line;
            my $title = "\"Go to first $key $covType ";
            if ('fileOrDir' eq $page_type) {
              # go to first line of the indicated type in the file
              $line = $fileDetails->nextTlaGroup($key)
                if $covType eq 'line';
              $line = $fileDetails->nextBranchTlaGroup($key)
                if $covType eq 'branch';
            } elsif ('owner' eq $page_type) {
              my $owner = $summary->owner();
              $title .= "in '$owner' bin ";
              $line = $fileDetails->nextInOwnerBin($owner, $key)
                if $covType eq 'line';
              $line = $fileDetails->nextBranchInOwnerBin($owner, $key)
                if $covType eq 'branch';
            } elsif ('date' eq $page_type) {
              my $agebin = $summary->bin();
              $title .= "in '$SummaryInfo::ageGroupHeader[$agebin]' bin ";
              $line = $fileDetails->nextInDateBin($agebin, $key)
                if $covType eq 'line';
              $line = $fileDetails->nextBranchInDateBin($agebin, $key)
                if $covType eq 'branch';
            } else {
              die("unexpected page detail type '$page_type'");
            }
            $title .= "in $filename\"";
            my $color = $class eq "tla$key" ? "style=\"background-color:$SummaryInfo::tlaColor{$key}\" " : "";
            if (defined($line)) {
              my $href = $tableHref;
              $href =~ s/__LINE__/$line/;
              $v = "<a $href ${color}title=$title>$v</a>";
            }
          }
        }
        write_html($handle, <<END_OF_HTML);
              <td class="$class">$v</td>
END_OF_HTML
      }

    } else {
      write_html($handle, <<END_OF_HTML);
              <td class="${prefix}coverNum$class">$hit / $found</td>
END_OF_HTML
    }
  }
  # End of row
  write_html($handle, <<END_OF_HTML);
            </tr>
END_OF_HTML
}


#
# write_file_table_detail_entry(filehandle, test_name, ([found, hit], ...))
#
# Write entry for detail section in file table.
#

sub write_file_table_detail_entry(*$@)
{
  my ($handle, $test, @entries) = @_;

  if ($test eq "") {
    $test = "<span style=\"font-style:italic\">&lt;unnamed&gt;</span>";
  } elsif ($test =~ /^(.*),diff$/) {
      $test = $1." (converted)";
  }
  # Testname
  write_html($handle, <<END_OF_HTML);
            <tr>
              <td class="testName" colspan=2>$test</td>
END_OF_HTML
  # Test data
  foreach my $entry (@entries) {
    my ($found, $hit) = @{$entry};
    my $rate = rate($hit, $found, "&nbsp;%");

    write_html($handle, <<END_OF_HTML);
              <td class="testPer">$rate</td>
              <td class="testNum">$hit&nbsp;/&nbsp;$found</td>
END_OF_HTML
  }

  write_html($handle, <<END_OF_HTML);
            </tr>

END_OF_HTML
}


#
# write_file_table_epilog(filehandle)
#
# Write end of file table HTML code.
#

sub write_file_table_epilog(*)
{
  # *************************************************************

  write_html($_[0], <<END_OF_HTML);
          </table>
          </center>
          <br>

END_OF_HTML
}


#
# write_test_table_prolog(filehandle, table_heading)
#
# Write heading for test case description table.
#

sub write_test_table_prolog(*$)
{
  write_html($_[0], <<END_OF_HTML);
          <center>
          <table width="80%" cellpadding=2 cellspacing=1 border=0>

            <tr>
              <td><br></td>
            </tr>

            <tr>
              <td class="tableHead">$_[1]</td>
            </tr>

            <tr>
              <td class="testDescription">
                <dl>
END_OF_HTML
}


#
# write_test_table_entry(filehandle, test_name, test_description)
#
# Write entry for the test table.
#

sub write_test_table_entry(*$$)
{
  write_html($_[0], <<END_OF_HTML);
          <dt>$_[1]<a name="$_[1]">&nbsp;</a></dt>
          <dd>$_[2]<br><br></dd>
END_OF_HTML
}


#
# write_test_table_epilog(filehandle)
#
# Write end of test description table HTML code.
#

sub write_test_table_epilog(*)
{
  # *************************************************************

  write_html($_[0], <<END_OF_HTML);
                </dl>
              </td>
            </tr>
          </table>
          </center>
          <br>

END_OF_HTML

  # *************************************************************
}


sub fmt_centered($$)
{
  my ($width, $text) = @_;
  my $w0 = length($text);
  my $w1 = $width > $w0 ? int(($width - $w0) / 2) : 0;
  my $w2 = $width > $w0 ? $width - $w0 - $w1 : 0;

  return (" "x$w1).$text.(" "x$w2);
}


#
# write_source_prolog(filehandle)
#
# Write start of source code table.
#

sub write_source_prolog(**)
{
  my $lineno_heading = " "x9;
  my $branch_heading = "";
  my $tlaWidth = 4;
  my $fileHasProjectData = $_[1];
  my $age_heading = "";
  my $owner_heading = "";
  my $tla_heading = "";
  if (defined($main::show_dateBins) &&
     $fileHasProjectData) {
    $age_heading = fmt_centered(5, "Age");
    $owner_heading = fmt_centered(20, "Owner");
  }
  if (defined($main::show_tla)) {
    $tla_heading = fmt_centered($tlaWidth, "TLA");
  }
  my $line_heading = fmt_centered($line_field_width, "Line data");
  my $source_heading = " Source code";

  if ($br_coverage) {
    $branch_heading = fmt_centered($br_field_width, "Branch data") . " ";
  }

  # *************************************************************

  write_html($_[0], <<END_OF_HTML);
          <table cellpadding=0 cellspacing=0 border=0>
            <tr>
              <td><br></td>
            </tr>
            <tr>
              <td>
<pre class="sourceHeading">${age_heading} ${owner_heading} ${lineno_heading}${branch_heading}${tla_heading}${line_heading} ${source_heading}</pre>
<pre class="source">
END_OF_HTML

  # *************************************************************
}

sub cmp_blocks($$)
{
  my ($a, $b) = @_;
  my ($fa, $fb) = ($a->[0], $b->[0]);

  return $fa->[0] <=> $fb->[0] if ($fa->[0] != $fb->[0]);
  return $fa->[1] <=> $fb->[1];
}

#
# get_branch_blocks(brdata)
#
# Group branches that belong to the same basic block.
#
# Returns: [block1, block2, ...]
# block:   [branch1, branch2, ...]
# branch:  [block_num, branch_num, taken_count, text_length, open, close]
#

sub get_branch_blocks($)
{
  my $brdata = shift;

  return () if (!defined($brdata));

  my $last_block_num;
  my $block = [];
  my @blocks;

  # Group branches
  foreach my $block_num (sort $brdata->blocks()) {
    my $blockData = $brdata->getBlock($block_num);
    my $branch = 0;
    foreach my $taken (@$blockData) {

      if (defined($last_block_num) && $block_num != $last_block_num) {
        push(@blocks, $block);
        $block = [];
      }
      my $br = [$block_num, $branch, $taken, 3, 0, 0];
      push(@{$block}, $br);
      $last_block_num = $block_num;
      ++ $branch;
    }
  }
  push(@blocks, $block) if (scalar(@{$block}) > 0);

  # Add braces to first and last branch in group
  foreach $block (@blocks) {
    $block->[0]->[$BR_OPEN] = 1;
    $block->[0]->[$BR_LEN]++;
    $block->[scalar(@{$block}) - 1]->[$BR_CLOSE] = 1;
    $block->[scalar(@{$block}) - 1]->[$BR_LEN]++;
  }

  return sort(cmp_blocks @blocks);
}

#
# get_block_len(block)
#
# Calculate total text length of all branches in a block of branches.
#

sub get_block_len($)
{
  my ($block) = @_;
  my $len = 0;

  foreach my $branch (@{$block}) {
    $len += $branch->[$BR_LEN];
  }

  return $len;
}


#
# get_branch_html(brdata, printCallbackStruct)
#
# Return a list of HTML lines which represent the specified branch coverage
# data in source code view.
#

sub get_branch_html($$)
{
  my ($brdata, $cbdata) = @_;
  my $differentialBranch;
  my $fileDetail = $cbdata->sourceDetail();
  if (defined($main::show_tla)) {
    my $lineNo = $cbdata->lineNo();
    my $lineData = $cbdata->lineData()->line($lineNo);
    $differentialBranch = $lineData->differential_branch()
      if defined($lineData);
  }
  # build the 'blocks' array from differential data if we have it..
  my @blocks = get_branch_blocks(defined($differentialBranch) ? $differentialBranch : $brdata);
  my $line_len = 0;
  my $line = [];  # [branch2|" ", branch|" ", ...]
  my @lines;      # [line1, line2, ...]
  my @result;

  # Distribute blocks to lines
  foreach my $block (@blocks) {
    my $block_len = get_block_len($block);

    # Does this block fit into the current line?
    if ($line_len + $block_len <= $br_field_width) {
      # Add it
      $line_len += $block_len;
      push(@{$line}, @{$block});
      next;
    } elsif ($block_len <= $br_field_width) {
      # It would fit if the line was empty - add it to new
      # line
      push(@lines, $line);
      $line_len = $block_len;
      $line = [ @{$block} ];
      next;
    }
    # Split the block into several lines
    foreach my $branch (@{$block}) {
      if ($line_len + $branch->[$BR_LEN] >= $br_field_width) {
        # Start a new line
        if (($line_len + 1 <= $br_field_width) &&
            scalar(@{$line}) > 0 &&
            !$line->[scalar(@$line) - 1]->[$BR_CLOSE]) {
          # Try to align branch symbols to be in
          # one # row
          push(@{$line}, " ");
        }
        push(@lines, $line);
        $line_len = 0;
        $line = [];
      }
      push(@{$line}, $branch);
      $line_len += $branch->[$BR_LEN];
    }
  }
  push(@lines, $line);

  my %tlaLinks;

  # Convert to HTML
  foreach $line (@lines) {
    my $current = "";
    my $current_len = 0;

    foreach my $branch (@$line) {
      # Skip alignment space
      if ($branch eq " ") {
        $current .= " ";
        $current_len++;
        next;
      }

      my ($block_num, $br_num, $taken, $len, $open, $close) = @{$branch};

      my $class;
      my $prefix;
      my $tla;
      if ('ARRAY' ne ref($taken)) {
        # vanilla case - no differential coverage info
        die("differential branch coverage but no TLA")
          if defined($differentialBranch);
        if ($taken eq '-') {
          $class  = "tlaUNC";
        } elsif ($taken == 0) {
          $class  = "tlaUNC";
        } else {
          $class  = 'tlaGBC';
        }
        $prefix = '';
      } else {
        die("differential branch coverage but no TLA") unless defined($differentialBranch);
        $tla = $taken->[1];
        $taken = $taken->[0];
        $class = "tla$tla";
        $prefix = $tla . ": ";
      }
      my $char;
      my $title;

      if ($taken eq '-') {
        $char   = "#";
        $title  = "${prefix}Branch $br_num was not executed";
      } elsif ($taken == 0) {
        $char   = "-";
        $title  = "${prefix}Branch $br_num was not taken";
      } else {
        $char   =  "+";
        $title  = "${prefix}Branch $br_num was taken $taken time"
            . (($taken > 1) ? "s" :"");
      }
      $current .= "[" if ($open);

      if (defined($differentialBranch)) {
        my $href;
        if (exists($tlaLinks{$tla})) {
          $href = $tlaLinks{$tla};
        }  else {
          my $line = $differentialBranch->line();
          my $next = $fileDetail->nextBranchTlaGroup($tla, $line);

          $href = "<a href=\"#" . (defined($next) ? $next : 'top')
                . "\" style=\"background-color:$SummaryInfo::tlaColor{$tla}\" title=\"$title\">$char</a>";
          $tlaLinks{$tla} = $href;
        }
        my $space = "<span class=\"$class\"> </span>";
        $current .= $space . $href . $space;
      } else {
        $current .= "<span class=\"$class\" title=\"$title\"> $char </span>";
      }
      $current .= "]" if ($close);
      $current_len += $len;
    }

    # Right-align result text
    if ($current_len < $br_field_width) {
      $current = (" "x($br_field_width - $current_len)).
           $current;
    }
    push(@result, $current);
  }

  return @result;
}


#
# format_count(count, width)
#
# Return a right-aligned representation of count that fits in width characters.
#

sub format_count($$)
{
        my ($count, $width) = @_;
        my $result;
        my $exp;

        $result = sprintf("%*.0f", $width, $count);
        while (length($result) > $width) {
                last if ($count < 10);
                $exp++;
                $count = int($count/10);
                $result = sprintf("%*s", $width, ">$count*10^$exp");
        }
        return $result;
}

#
# write_source_line(filehandle, cbdata, source, hit_count, brdata,
#                   printCallbackStruct)
#
# Write formatted source code line. Return a line in a format as needed
# by gen_png()
#

sub write_source_line(*$$$$)
{
    my ($handle, $srcline, $count, $brdata, $cbdata) = @_;
    my $line = $cbdata->lineNo();
    my $lineCovInfo = $cbdata->lineData();
    my $source = $srcline->text();
    my $src_owner = $srcline->owner();
    $src_owner =~ s/@.*// if defined($src_owner);
    my $src_age = $srcline->age();
    my $source_format;
    my $count_format;
    my $result;
    my $anchor_start = "";
    my $anchor_end = "";
    my $count_field_width = $line_field_width - 1;
    my @br_html;
    my $html;
    my $tla;
    my $base_count;
    my $curr_count;
    my $bucket;
    my %pngChar = (
        'CBC' => '',
        'LBC' => '',
        'GBC' => '-',
        'UBC' => '-',
        'ECB' => '<',
        'EUB' => '<',
        'GIC' => '>',
        'UIC' => '>',
        'GNC' => '+',
        'UNC' => '+',
        );

    my @prevData = ($cbdata->current('tla'),
                    $cbdata->current('owner'),
                    $cbdata->current('age'));

    # Get branch HTML data for this line
    @br_html = get_branch_html($brdata, $cbdata) if ($main::br_coverage);

    my $thisline = $lineCovInfo->{$line};
    my $tlaIsHref;
    if (!defined($thisline) ||
        (!defined($count) &&
         !($thisline->in_base() || $thisline->in_curr()))) {
        $result         = "";
        $source_format  = "";
        $count_format   = " "x$count_field_width;
        $tla = $cbdata->tla(undef, $line);
    } else {
        $base_count = $thisline->base_count();
        $curr_count = $thisline->curr_count();
        $bucket = $thisline->tla();
        # use callback data to keep track of the most recently seen TLA -
        #   $tla is either "   " (3 spaces) if same as previous or if no TLA
        #   we just stick "TLA " (4 characters) into the fixed-with source
        #   line - right before the count.
        $tla = $cbdata->tla($bucket, $line);
        if ($tla eq $bucket) {
            # maybe we want to link only the uncovered code categories?
            my $next = $cbdata->sourceDetail()->nextTlaGroup($bucket, $line);
            $tlaIsHref = 1;
            # if no next segment in this category - then go to top to page.
            $next = 'top' if (!defined($next));
            my $color =
                " style=\"background-color:$SummaryInfo::tlaColor{$bucket}\"";
            my $popup = "title=\"Next $bucket group\"";
            $tla = "<a href=\"#$next\"$color$popup>$tla</a>";
        }
        $source_format  = "<span class=\"tla$bucket\">";

        exists($pngChar{$bucket})
            or die("unexpected TLA '$bucket'");
        my $pchar = $pngChar{$bucket};
        if ($bucket eq "ECB" ||
            $bucket eq "EUB" ) {
            ! defined($count) or
                die("excluded code should have undefined count");
            # don't show count for excluded code
            $count_format  = " "x$count_field_width;
            $result        = $pchar . $base_count;
        } else {
            defined($count) && "" ne $count
                or die("code should have defined count");
            $count_format = format_count($count, $count_field_width);
            $result       = $pchar . $count;
        }
        # '$result' is used to generate the PNG frame
        lcovutil::verbose("    $bucket: line=$line " .
                          (defined($count) ? "count= $count " : "") .
                          "curr=$curr_count base=$base_count\n");
    }
    $result .= ":".$source;

    # Write out a line number navigation anchor every $nav_resolution
    # lines if necessary
    $anchor_start   = "<a name=\"$line\">";
    $anchor_end     = "</a>";

    # *************************************************************

    $html = $anchor_start;
    # we want to colorize the date/owner part of un-hit lines only
    my $html_continuation_leader = ""; # for continued lines
    if (defined($main::show_dateBins) &&
        $cbdata->sourceDetail()->isProjectFile()) { DATE_SECTION: {

      my $ageLen = 5;
      my $ownerLen = 20;

      # need to space over on continuation lines
      $html_continuation_leader = ' 'x($ageLen + $ownerLen + 2);

      if (! defined($count) &&
          (!defined($main::show_nonCodeOwners) ||
           0 == $main::show_nonCodeOwners) &&
          (! defined($bucket) ||
           ($bucket ne 'EUB' &&
            $bucket ne 'ECB'))) {
          # suppress date- and owner entry on non-code lines
        $html .= $html_continuation_leader;
        last DATE_SECTION;
      }

      my $span = "";
      my $endspan = "";
      my $bgcolor = "";
      if (defined($count) && 0 == $count) {
        # probably want to pick a color based on which
        #   date bin it is in.
        # right now, picking based on TLA.
        $bgcolor = " style=\"background-color:$SummaryInfo::tlaColor{$bucket}\""
          if (defined($bucket) && $bucket ne "EUB" && $bucket ne "ECB");

        #$html .= "<span class=\"missBins\">";
        if ("" ne $source_format) { OWNER: {
          if (! defined($src_owner) || ! defined($src_age)) {
            # maybe this should be a different error type?
            main::ignorable_eror($ERROR_UNMAPPED_LINE,
                                 "undefined owner/age for $bucket $line " .
                                 $cbdata->sourceDetail()->path());
            last OWNER;
          }
          # add a 'title="tooltip"' popup - to give owner, date, etc
          my $title = "span title=\"$src_owner $src_age days ago";
          if (defined($main::show_dateBins)) {
            my $bin = SummaryInfo::findAgeBin($src_age);
            $title .=
                " (bin $bin: " . $SummaryInfo::ageGroupHeader[$bin] . ")";
          }
          $title .= "\"";
          $span = $source_format;
          $span =~ s/span/$title/;
          $endspan = "</span>";
        }
      } } # OWNER block

      # determine if this line is going to be the target of a 'date', 'owner'
      # or TLA navigation href.
      #  - is is possible for any of these to have changed from the previous
      #    line, even if the others are unchanged:
      #      - same TLA but different author
      #      - same author but different date bin, .. and so on
      # If it is a leader, then we need to insert the 'owner' and/or 'date'
      #   link to go to the next group in this bin - even if the owner or
      #   date bin has not changed from the previous line)
      my $tlaChanged = defined($bucket) && $prevData[0] ne $bucket;

      my $needOwnerHref = ($tlaChanged ||
                           (defined($bucket) && $prevData[1] ne $src_owner));

      my $newBin = SummaryInfo::findAgeBin($src_age);
      defined($prevData[2]) || $line == 1
          or die("unexpected uninitialized age");

      my $needDateHref = ($tlaChanged ||
                          (defined($bucket) &&
                           SummaryInfo::findAgeBin($prevData[2]) != $newBin));

      if ($needDateHref) {
        my $matchLine = $cbdata->nextDate($newBin, $bucket);
        $needDateHref = 0
          if (defined($matchLine) && $matchLine != $line);
      }
      if ($needOwnerHref) {
        # slightly complicated logic:
        #   - there can be non-code lines owned by someone else
        #     between code lines owned by '$src_owner', such that the
        #     all the code lines have the same TLA.
        # In that case, we just insert an href at the top of the
        # block to take us past all of of them - to the next code block
        # owned by $src_owner with this TLA, which separated by at least
        # one line of code either owned by someone else, or with a different
        # TLA.
        my $matchLine = $cbdata->nextOwner($src_owner, $bucket);
        # don't insert the owner href if this isn't the line we wanted
        $needOwnerHref = 0
            if (defined($matchLine) && $matchLine != $line);
      }

      my $age = $cbdata->age($src_age, $line);
      my $owner = $cbdata->owner($src_owner);

      # this HTML block turns into
      #   "<span ...>int name</span> " <- note trailing space
      #  .. but the age and name might be hrefs

      $html .= $span;
      # then 5 characters of 'age' (might be empty)
      if ($needDateHref) {
        # next line with this TLA, in this date bin
        my $next = $cbdata->sourceDetail()->nextInDateBin($newBin,
                                                          $bucket, $line);
        $cbdata->nextDate($newBin, $bucket, $next);

        $next = "top" if (!defined($next));
        my $dateBin = $SummaryInfo::ageGroupHeader[$newBin];
        my $popup =  " title=\"next $bucket in &ldquo;$dateBin&rdquo; bin\"";
        $html .= ( (' 'x($ageLen-length($src_age))) .
                   "<a href=\"#$next\"$popup$bgcolor>$src_age</a> " );
      } else {
        $html .= sprintf("%${ageLen}s ", $age);
      }

      if ($needOwnerHref) {
        # next line with this TLA, by this owner..
        my $next = $cbdata->sourceDetail()->nextInOwnerBin($src_owner,
                                                           $bucket, $line);
        $cbdata->nextOwner($src_owner, $bucket, $next);
        $next = "top" if (!defined($next));
        my $popup =  " title=\"next $bucket in &ldquo;$src_owner&rdquo; bin\"";
        # NOTE:  see note below about firefox nested span bug.
        #  this code just arranges to wrap an explicit 'span' around
        #  the space.
        my $space = ' 'x($ownerLen-length($src_owner));
        my $href = "<a href=\"#$next\"$popup$bgcolor>$src_owner</a>";
        if ('' ne $bgcolor &&
            '' ne $space) {
          $html .= "$endspan$href$span";
        } else {
          $html .= $href;
        }
        $html .= $space;
      } else {
        $html .= sprintf("%-${ownerLen}s", $owner);
      }
      $html .= $endspan . ' '; # add trailing space
    } } # DATE_SECTION

    $html .= sprintf("<span class=\"lineNum\">%8d</span> ", $line);
    #printf("tla= " . $tla);
    #printf("html= " . $html);
    $html .= shift(@br_html).":" if ($main::br_coverage);

    $tla = ""
        if (! defined($main::show_tla));

    # 'source_format is the colorization, then the 3-letter TLA,
    #    then the hit count, then the source line
    if ($tlaIsHref) {
        # there seems to be a bug in firefox:
        #      <span class="foo"><a href...>link</a> whatever</span>
        #   renders as if the 'span' didn't exist (so the colorization of the
        #   link end - and the rest of the line doesn't pick up attributes
        #   from class 'foo'.
        # If I emit it as:
        #     <a href...>link</a><span ....> wheatever</span>
        #   (i.e., do not nest anchor inside the span) - then it works
        $html .= "$tla$source_format $count_format : ";
    } else {
        $html .= "$source_format$tla $count_format : ";
    }

    $html .= escape_html($source);
    $html .= "</span>" if ($source_format);
    $html .= $anchor_end."\n";

    write_html($handle, $html);

    if ($main::br_coverage) {
        # Add lines for overlong branch information
        foreach (@br_html) {
            write_html($handle,
                       "$html_continuation_leader<span class=\"lineNum\">"
                       . ' 'x8 . "</span> $_\n");
        }
    }
    # *************************************************************

    return($result);
}


#
# write_source_epilog(filehandle)
#
# Write end of source code table.
#

sub write_source_epilog(*)
{
  # *************************************************************

  write_html($_[0], <<END_OF_HTML);
        </pre>
              </td>
            </tr>
          </table>
          <br>

END_OF_HTML

  # *************************************************************
}


#
# write_html_epilog(filehandle, base_dir[, break_frames])
#
# Write HTML page footer to FILEHANDLE. BREAK_FRAMES should be set when
# this page is embedded in a frameset, clicking the URL link will then
# break this frameset.
#

sub write_html_epilog(*$;$)
{
  my $basedir = $_[1];
  my $break_code = "";
  my $epilog;

  if (defined($_[2]))
  {
    $break_code = " target=\"_parent\"";
  }

  # *************************************************************

  write_html($_[0], <<END_OF_HTML);
          <table width="100%" border=0 cellspacing=0 cellpadding=0>
            <tr><td class="ruler"><img src="$_[1]glass.png" width=3 height=3 alt=""></td></tr>
            <tr><td class="versionInfo">Generated by: <a href="$lcov_url"$break_code>$lcov_version</a></td></tr>
          </table>
          <br>
END_OF_HTML

  $epilog = $html_epilog;
  $epilog =~ s/\@basedir\@/$basedir/g;

  write_html($_[0], $epilog);
}


#
# write_frameset(filehandle, basedir, basename, pagetitle)
#
#

sub write_frameset(*$$$)
{
  my $frame_width = $overview_width + 40;

  # *************************************************************

  write_html($_[0], <<END_OF_HTML);
        <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN">

        <html lang="en">

        <head>
          <meta http-equiv="Content-Type" content="text/html; charset=$charset">
          <title>$_[3]</title>
          <link rel="stylesheet" type="text/css" href="$_[1]gcov.css">
        </head>

        <frameset cols="$frame_width,*">
          <frame src="$_[2].gcov.overview.$html_ext" name="overview">
          <frame src="$_[2].gcov.$html_ext" name="source">
          <noframes>
            <center>Frames not supported by your browser!<br></center>
          </noframes>
        </frameset>

        </html>
END_OF_HTML

        # *************************************************************
}


#
# sub write_overview_line(filehandle, basename, line, link)
#
#

sub write_overview_line(*$$$)
{
  my $y1 = $_[2] - 1;
  my $y2 = $y1 + $nav_resolution - 1;
  my $x2 = $overview_width - 1;

  # *************************************************************

  write_html($_[0], <<END_OF_HTML);
            <area shape="rect" coords="0,$y1,$x2,$y2" href="$_[1].gcov.$html_ext#$_[3]" target="source" alt="overview">
END_OF_HTML
  # *************************************************************
}


#
# write_overview(filehandle, basedir, basename, pagetitle, lines)
#
#

sub write_overview(*$$$$)
{
        my $index;
        my $max_line = $_[4] - 1;
        my $offset;

        # *************************************************************

        write_html($_[0], <<END_OF_HTML);
        <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

        <html lang="en">

        <head>
          <title>$_[3]</title>
          <meta http-equiv="Content-Type" content="text/html; charset=$charset">
          <link rel="stylesheet" type="text/css" href="$_[1]gcov.css">
        </head>

        <body>
          <map name="overview">
END_OF_HTML

        # *************************************************************

        # Make $offset the next higher multiple of $nav_resolution
        $offset = ($nav_offset + $nav_resolution - 1) / $nav_resolution;
        $offset = sprintf("%d", $offset ) * $nav_resolution;

        # Create image map for overview image
        for ($index = 1; $index <= $_[4]; $index += $nav_resolution)
        {
                # Enforce nav_offset
                if ($index < $offset + 1)
                {
                        write_overview_line($_[0], $_[2], $index, 1);
                }
                else
                {
                        write_overview_line($_[0], $_[2], $index, $index - $offset);
                }
        }

        # *************************************************************

        write_html($_[0], <<END_OF_HTML);
          </map>

          <center>
          <a href="$_[2].gcov.$html_ext#top" target="source">Top</a><br><br>
          <img src="$_[2].gcov.png" width=$overview_width height=$max_line alt="Overview" border=0 usemap="#overview">
          </center>
        </body>
        </html>
END_OF_HTML

        # *************************************************************
}


sub max($$)
{
  my ($a, $b) = @_;

  return $a if ($a > $b);
  return $b;
}


sub buildDateSummaryTable($$$$$$$$) {
  my ($summary, $covType, $covCountCallback, $fileDetail,
      $nextLocationCallback, $title, $detailLink, $numRows) = @_;

  $title = "<a href=\"$detailLink\">$title</a>"
    if (defined($detailLink));

  my @table;

  my @dateSummary = [undef, #width
                     "subTableHeader", # class
                     $title, # text
                     $numRows, # colspan
    ];
  # only insert the label if there is data
  my $first = 1;
  for (my $bin = 0 ; $bin <= $#SummaryInfo::ageGroupHeader ; ++ $bin) {
    my $ageval = $summary->age_sample($bin);
    my $found = &$covCountCallback($summary, "found", "age", $ageval);
    next
      if 0 == $found;
    my $hit = &$covCountCallback($summary, "hit", "age", $ageval);
    my $style = $rate_name[classify_rate($found, $hit, $med_limit, $hi_limit)];
    my $rate = rate($hit, $found, "&nbsp;%");
    my @dataRow = ([undef, "headerItem", $SummaryInfo::ageGroupHeader[$bin].":"],
                   [undef, "headerCovTableEntry$style", $rate],
                   [undef, "headerCovTableEntry", $found],
                   [undef, "headerCovTableEntry", $hit]);
    if ( $main::show_tla) {
      for my $tla (@SummaryInfo::tlaPriorityOrder) {
        my $value = &$covCountCallback($summary, $tla, "age", $ageval);
        my $class =
          0 != $value && grep(/^$tla$/, ("UNC", "LBC", "UIC")) ? "tla$tla" : "headerCovTableEntry";
        # suppress zeros - make table less busy/easier to read
        if ("0" eq $value) {
          $value = "";
        } elsif (defined($fileDetail) &&
                 defined($nextLocationCallback) &&
                 $tla ne 'DCB' &&
                 $tla ne 'DUB') {
          # link to first entry
          my $firstAppearance = &$nextLocationCallback($fileDetail, $bin, $tla);
          defined($firstAppearance)
            or die("$tla: unexpected date bin $bin undef appearance for " . $fileDetail->path());
          my $dateBin = $SummaryInfo::ageGroupHeader[$bin];
          my $popup =  " title=\"goto first $tla ";
          $popup .= $covType . ' '
            if ($covType ne 'line');
          $popup .= "in &ldquo;$dateBin&rdquo; bin\"";
          my $color = " style=\"background-color:$class\"";
          $value = "<a href=\"#$firstAppearance\"$popup$color>$value</a>";
        }
        push(@dataRow, [undef, $class, $value]);
      }
    }
    if ($first) {
      push(@table, \@dateSummary);
      $first = 0;
    }
    push(@table, \@dataRow);
  }
  return \@table;
}

sub buildOwnerSummaryTable($$$$$$$$) {
  my ($ownerList, $summary, $covType,
      $fileDetail, $nextLocationCallback,
      $title, $detailLink, $numRows) = @_;

  $title .= " (containing " .
    ($main::show_ownerBins ? "" : "un-exercised ") . "code)";

  $title = "<a href=\"$detailLink\">$title</a>"
    if (defined($detailLink));

  my @table;
  my @ownerSummary = [undef, #width
                     "subTableHeader", # class
                     $title, # text
                     $numRows, # colspan
    ];

  my $first = 1;
  # owners are sorted from most uncovered lines to least
  foreach my $od (@$ownerList) {
    my ($name, $lineData, $branchData) = @$od;
    my $d = ($covType eq 'line') ? $lineData : $branchData;
    my ($missed, $found) = @$d;

    # only put user in table if they are responsible for at least one point
    next if $found == 0 or ($missed == 0 && $main::show_ownerBins ne 'all');

    if ( $first ) {
      $first = 0;
      push(@table, \@ownerSummary);
    }
    my $hit = $found - $missed;

    my $style = $rate_name[classify_rate($found, $hit, $med_limit, $hi_limit)];
    my $rate = rate($hit, $found, '&nbsp;%');

    my @dataRow = ([undef, "headerItem", $name . ":"],
                   [undef, "owner_coverPer$style", $rate],
                   [undef, "ownerTla", $found],
                   [undef, "ownerTla", $hit]);
    # no differential counts for branch coverage, yet
    if ( $main::show_tla) {
      for my $tla (@SummaryInfo::tlaPriorityOrder) {
        my $value = $summary->owner_tlaCount($name, $tla, $covType);
        # suppress zeros - make table less busy/easier to read
        my $class =
          0 != $value && grep(/^$tla$/, ("UNC", "LBC", "UIC")) ? "tla$tla" : "ownerTla";
        if ("0" eq $value) {
          $value = "";
        } elsif (defined($fileDetail) &&
                 defined($nextLocationCallback)) {
          my $firstAppearance = &$nextLocationCallback($fileDetail,
                                                       $name, $tla);
          defined($firstAppearance) or
            die("$tla: unexpected owner $name undef appearance for " . $fileDetail->path());
          my $popup =  " title=\"goto first $tla ";
          $popup .= $covType . ' '
            if ($covType ne 'line');
          $popup .= "in &ldquo;$name&rdquo; bin\"";
          my $color = " style=\"background-color:$class\"";
          $value = "<a href=\"#$firstAppearance\"$popup$color>$value</a>";
          }
        push(@dataRow, [undef, $class, $value]);
      }
    }
    push(@table, \@dataRow);
  }
  return \@table;
}

sub buildHeaderSummaryTableRow {
  my ($summary, $covType, $fileDetail, $nextLocationCallback) = @_;

  $fileDetail = undef
    if (defined($fileDetail) && $fileDetail->notProjectFile());
  my @row;
  for my $tla (@SummaryInfo::tlaPriorityOrder) {
    my $value = $summary->get($tla, $covType);
    # suppress zeros - make table less busy/easier to read
    if ( "0" eq $value) {
      $value = "";
    } elsif (defined($fileDetail) &&
             ! ($tla eq "DCB" || $tla eq "DUB")) {
      # deleted lines don't appear..
      my $firstAppearance = &$nextLocationCallback($fileDetail, $tla);
      defined($firstAppearance) or
        die("$tla: unexpected undef appearance for " . $fileDetail->path());
      my $popup = " title=\"goto first ";
      $popup .= $covType . ' '
        if $covType ne 'line';
      $popup .= "$tla\"";
      $value = "<a href=\"#$firstAppearance\"$popup>$value</a>";
    }
    push(@row, [undef, "headerCovTableEntry", $value]);
  }
  return @row;
}

#
# write_header(filehandle, ctrl, trunc_file_name, rel_file_name,
#              summaryInfo, optionalFileDetailInfo))
#  ctrl = (type, sort_type, bin_type)
#
# Write a complete standard page header. TYPE may be (0, 1, 2, 3, 4)
# corresponding to (directory view header, file view header, source view
# header, test case description header, function view header)
#
# bin_type in (undef, "", "-owner", "-date")
#  - if 'bin' is set, then create link to 'vanilla' view of self, and
#    to corresponding view of parent
#      - i.e., from 'owner detail' directory page to "owner detail"
#        toplevel, and to my correspondign vanilla directory page.

sub write_header(*$$$$$)
{
  local *HTML_HANDLE = $_[0];
  my $ctrl = $_[1];
  my $trunc_name = $_[2];
  my $rel_filename = $_[3];
  my $summary = $_[4];
  my $fileDetail = $_[5];
  my ($type, $sort_type, $bin_type) = @$ctrl;
  my $base_dir;
  my $view;
  my $test;
  my $base_name;
  my $style;
  my $rate;
  my @row_left;
  my @row_right;
  my $num_rows;
  my $i;
  my $esc_trunc_name = escape_html($trunc_name);

  $bin_type = ""
      unless defined($bin_type);
  $base_name = basename($rel_filename);
  my $show_dateBins =
      $main::show_dateBins &&
      (! defined($fileDetail) || $fileDetail->isProjectFile());

  # Prepare text for "current view" field
  if ($type == $HDR_DIR)
  {
    # Main overview
    $base_dir = "";
    if ($bin_type ne "") {
      # this is the header of the 'top-level' page, for some
      #   either 'owner' or 'date' binning - link back to
      #   vanilla top-level page
      $view = "<a href=\"index.$html_ext\">$overview_title</a>";
    } else {
      $view = $overview_title;
    }
  }
  elsif ($type == $HDR_FILE)
  {
    # Directory overview
    $base_dir = get_relative_base_path($rel_filename);
    my $self_link = (("" eq $bin_type)
                     ? $esc_trunc_name
                     : "<a href=\"index.$html_ext\">$esc_trunc_name</a>");
    $view = "<a href=\"$base_dir"."index$bin_type.$html_ext\">".
        "$overview_title</a> - $self_link";
  }
  elsif ($type == $HDR_SOURCE || $type == $HDR_FUNC)
  {
    # File view
    my $dir_name = dirname($rel_filename);
    my $esc_base_name = escape_html($base_name);
    my $esc_dir_name = escape_html($dir_name);

    $base_dir = get_relative_base_path($dir_name);
    if ($frames)
    {
      # Need to break frameset when clicking any of these links
      $view = "<a href=\"$base_dir"."index.$html_ext\" ".
          "target=\"_parent\">$overview_title</a> - ".
          "<a href=\"index.$html_ext\" target=\"_parent\">".
          "$esc_dir_name</a> - $esc_base_name";
    }
    else
    {
      $view = "<a href=\"$base_dir"."index.$html_ext\">".
          "$overview_title</a> - ".
          "<a href=\"index.$html_ext\">".
          "$esc_dir_name</a> - $esc_base_name";
    }

    # Add function suffix
    if ($func_coverage) {
      $view .= "<span style=\"font-size: 80%;\">";
      if ($type == $HDR_SOURCE) {
        if ($sort) {
          $view .= " (source / <a href=\"$base_name.func-sort-c.$html_ext\">functions</a>)";
        } else {
          $view .= " (source / <a href=\"$base_name.func.$html_ext\">functions</a>)";
        }
      } elsif ($type == $HDR_FUNC) {
          $view .= " (<a href=\"$base_name.gcov.$html_ext\">source</a> / functions)";
      }
      $view .= "</span>";
    }
  }
  elsif ($type == $HDR_TESTDESC)
  {
    # Test description header
      $base_dir = "";
      $view = "<a href=\"$base_dir"."index.$html_ext\">".
          "$overview_title</a> - test case descriptions";
  }

  # Prepare text for "test" field
  $test = escape_html($test_title);

  # Append link to test description page if available
  if (%test_description && ($type != $HDR_TESTDESC))
  {
    if ($frames && ($type == $HDR_SOURCE || $type == $HDR_FUNC))
    {
      # Need to break frameset when clicking this link
      $test .= " ( <span style=\"font-size:80%;\">".
          "<a href=\"$base_dir".
          "descriptions.$html_ext\" target=\"_parent\">".
          "view descriptions</a></span> )";
    }
    else
    {
        $test .= " ( <span style=\"font-size:80%;\">".
            "<a href=\"$base_dir".
            "descriptions.$html_ext\">".
            "view descriptions</a></span> )";
    }
  }

  # Write header
  write_header_prolog(*HTML_HANDLE, $base_dir);

  # Left row
  push(@row_left, [[ "10%", "headerItem", "Current view:" ],
                   [ "10%", "headerValue", $view ]]);
  my $label = defined($baseline_title) ? "Current" : "Test";
  push(@row_left, [[undef, "headerItem", "$label:"],
                   [undef, "headerValue", $test]]);
  push(@row_left, [[undef, "headerItem", "$label Date:"],
                   [undef, "headerValue", $date]]);
  if (defined($baseline_title)) {
      push(@row_left, [[undef, "headerItem", "Baseline:"],
                       [undef, "headerValue", $baseline_title]]);
      push(@row_left, [[undef, "headerItem", "Baseline Date:"],
                       [undef, "headerValue", $baseline_date]]);
  }
  if ($type != $HDR_SOURCE &&
      (defined($main::show_ownerBins) ||
       defined($SourceFile::annotateScript))) {
    # we are going to have 3 versions of of the page:
    #   flat, with owner bin data, with date bin data
    # so label which one this is
    my $thisView;
    if ($bin_type eq '-owner') {
        $thisView = "Ownership bin detail";
    } elsif ($bin_type eq '-date') {
        $thisView = "Date bin detail";
    } else {
        $bin_type eq ""
            or die("unexpected bin detail type $bin_type");
        $thisView = "Flat";
    }
    push(@row_left, [[undef, 'headerItem', 'View type:'],
                     [undef, 'headerValue', $thisView]]);
  }

  # Right row
  if ($legend && ($type == $HDR_SOURCE || $type == $HDR_FUNC)) {
    my $text = <<END_OF_HTML;
            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
END_OF_HTML
    if ($main::br_coverage) {
        $text .= <<END_OF_HTML;
            | Branches:
            <span class="coverLegendCov">+</span> taken
            <span class="coverLegendNoCov">-</span> not taken
            <span class="coverLegendNoCov">#</span> not executed
END_OF_HTML
    }
    push(@row_left, [[undef, "headerItem", "Legend:"],
                     [undef, "headerValueLeg", $text]]);
  } elsif ($legend && ($type != $HDR_TESTDESC)) {
    my $text = <<END_OF_HTML;
            Rating:
            <span class="coverLegendCovLo" title="Coverage rates below $med_limit % are classified as low">low: &lt; $med_limit %</span>
            <span class="coverLegendCovMed" title="Coverage rates between $med_limit % and $hi_limit % are classified as medium">medium: &gt;= $med_limit %</span>
            <span class="coverLegendCovHi" title="Coverage rates of $hi_limit % and more are classified as high">high: &gt;= $hi_limit %</span>
END_OF_HTML
    push(@row_left, [[undef, "headerItem", "Legend:"],
                     [undef, "headerValueLeg", $text]]);
  }
  if ($type == $HDR_TESTDESC) {
    push(@row_right, [[ "80%" ]]);
  } else {
    my $totalTitle = "Covered + Uncovered code";
    my $hitTitle = "Exercised code only";
    if ($main::show_tla) {
      $totalTitle .= " (not including EUB, ECB, DUB, DCB categories)";
      $hitTitle .= " (CBC + GBC + GNC + GIC)";
    }

    my @headerRow = (["5%", undef, undef ],
                     ["5%", "headerCovTableHead", "Coverage"],
                     ["5%", "headerCovTableHead\" title=\" $totalTitle\"",
                      "Total" ],
                     ["5%", "headerCovTableHead\" title=\" $hitTitle\"",
                      "Hit" ]);
    if ( $main::show_tla) {
      for my $tla (@SummaryInfo::tlaPriorityOrder) {
        my $title = $SummaryInfo::tlaToTitle{$tla};
        push(@headerRow, ["5%", "headerCovTableHead\" title=\"$title",
                          "<span class=\"tla$tla\">$tla</span>"]);
      }
    }
    push(@row_right, \@headerRow);
  }
  # Line coverage
  $style = $rate_name[classify_rate($summary->l_found(), $summary->l_hit(),
                                    $med_limit, $hi_limit)];
  $rate = rate($summary->l_hit(), $summary->l_found(), "&nbsp;%");
  my @dataRow = ( [undef, "headerItem", "Lines:"],
                  [undef, "headerCovTableEntry$style", $rate],
                  [undef, "headerCovTableEntry", $summary->l_found()],
                  [undef, "headerCovTableEntry", $summary->l_hit()]
      );
  if ($main::show_tla) {
    my @tlaRow = buildHeaderSummaryTableRow($summary, 'line', $fileDetail,
                                            \&SourceFile::nextTlaGroup);
    push(@dataRow, @tlaRow);
  }
  push(@row_right, \@dataRow)
      if ($type != $HDR_TESTDESC);
  # Function coverage
  if ($func_coverage) {
    $style = $rate_name[classify_rate($summary->f_found(), $summary->f_hit(),
                                      $fn_med_limit, $fn_hi_limit)];
    $rate = rate($summary->f_hit(), $summary->f_found(), "&nbsp;%");
    my @dataRow = ([undef, "headerItem", "Functions:"],
                   [undef, "headerCovTableEntry$style", $rate],
                   [undef, "headerCovTableEntry", $summary->f_found()],
                   [undef, "headerCovTableEntry", $summary->f_hit()]);
    if ($main::show_tla) {
      # no differential counts for functions, yet
      for my $tla (@SummaryInfo::tlaPriorityOrder) {
          push(@dataRow, [undef, "headerCovTableEntry", ""]);
      }
    }
    push(@row_right, \@dataRow)
        if ($type != $HDR_TESTDESC);
  }
  # Branch coverage
  if ($br_coverage) {
    $style = $rate_name[classify_rate($summary->b_found(), $summary->b_hit(),
                                      $br_med_limit, $br_hi_limit)];
    $rate = rate($summary->b_hit(), $summary->b_found(), "&nbsp;%");
    my @dataRow = ([undef, "headerItem", "Branches:"],
                   [undef, "headerCovTableEntry$style", $rate],
                   [undef, "headerCovTableEntry", $summary->b_found()],
                   [undef, "headerCovTableEntry", $summary->b_hit()]);
    if ($main::show_tla) {
      my @tlaRow =
        buildHeaderSummaryTableRow($summary, 'branch', $fileDetail,
                                   \&SourceFile::nextBranchTlaGroup);
      push(@dataRow, @tlaRow);
    }
    push(@row_right, \@dataRow)
        if ($type != $HDR_TESTDESC);
  }

  # Aged coverage
  if ($show_dateBins) {
    # make a space in the table between before date bins
    my $dateBinDetailPage="index-date.$html_ext"
      if $type != $HDR_SOURCE;

    my $table =
      buildDateSummaryTable($summary, "line", \&SummaryInfo::lineCovCount,
                              $fileDetail, \&SourceFile::nextInDateBin,
                              "Line coverage date bins:",
                              $dateBinDetailPage, scalar(@dataRow));
    push(@row_right, @$table);

    if ($br_coverage) {
      my $br_table =
        buildDateSummaryTable($summary, "branch",
                              \&SummaryInfo::branchCovCount, $fileDetail,
                              \&SourceFile::nextBranchInDateBin,
                              "Branch coverage date bins:",
                              $dateBinDetailPage, scalar(@dataRow));
      push(@row_right, @$br_table);
    }
  }
  # owner bins..
  if (defined($main::show_ownerBins)) {
    # first, make sure there is owner data here (ie., owner data
    #   was collected, or both that there is owner data and some
    #   owners have uncovered code)
    my $ownerList = $summary->findOwnerList($main::show_ownerBins &&
                                            $main::show_ownerBins eq 'all');
    if (defined($ownerList)) {
      my $ownerBinDetailPage="index-owner.$html_ext"
        if $type != $HDR_SOURCE;

      my $table =
        buildOwnerSummaryTable($ownerList, $summary, 'line',
                               $fileDetail, \&SourceFile::nextInOwnerBin,
                               "Line coverage ownership bins",
                               $ownerBinDetailPage, scalar(@dataRow));
      push(@row_right, @$table);

      if ($br_coverage) {
        my $br_table =
          buildOwnerSummaryTable($ownerList, $summary, 'branch',
                                 $fileDetail, \&SourceFile::nextBranchInOwnerBin,
                                 "Branch coverage ownership bins",
                                 $ownerBinDetailPage, scalar(@dataRow));
        push(@row_right, @$br_table);
      }
    }
  }

  # Print rows
  $num_rows = max(scalar(@row_left), scalar(@row_right));
  for ($i = 0; $i < $num_rows; $i++) {
    my $left = $row_left[$i];
    my $right = $row_right[$i];

    if (!defined($left)) {
      $left = [[undef, undef, undef], [undef, undef, undef]];
    }
    if (!defined($right)) {
      $right = [];
    }
    write_header_line(*HTML_HANDLE, @{$left},
                      [ $i == 0 ? "5%" : undef, undef, undef],
                      @{$right});
  }

  # Fourth line
  write_header_epilog(*HTML_HANDLE, $base_dir);
}

sub get_sorted_by_rate($$)
{
        my ($hash, $type) = @_;

        if ($type == $SORT_LINE) {
                # Sort by line coverage
                return sort({$hash->{$a}[7] <=> $hash->{$b}[7]} keys(%{$hash}));
        } elsif ($type == $SORT_FUNC) {
                # Sort by function coverage;
                return sort({$hash->{$a}[8] <=> $hash->{$b}[8]} keys(%{$hash}));
        } elsif ($type == $SORT_BRANCH) {
                # Sort by br coverage;
                return sort({$hash->{$a}[9] <=> $hash->{$b}[9]} keys(%{$hash}));
        }
}

sub get_sorted_by_missed($$)
{
        my ($hash, $type) = @_;

        if ($type == $SORT_LINE) {
                # Sort by number of instrumented lines without coverage
                return sort(
                        {
                                ($hash->{$b}[0] - $hash->{$b}[1]) <=>
                                ($hash->{$a}[0] - $hash->{$a}[1])
                        } keys(%{$hash}));
        } elsif ($type == $SORT_FUNC) {
                # Sort by number of instrumented functions without coverage
                return sort(
                        {
                                ($hash->{$b}[2] - $hash->{$b}[3]) <=>
                                ($hash->{$a}[2] - $hash->{$a}[3])
                        } keys(%{$hash}));
        } elsif ($type == $SORT_BRANCH) {
                # Sort by number of instrumented branches without coverage
                return sort(
                        {
                                ($hash->{$b}[4] - $hash->{$b}[5]) <=>
                                ($hash->{$a}[4] - $hash->{$a}[5])
                        } keys(%{$hash}));
        }
}

#
# get_sorted_keys(hash_ref, sort_type)
#
# hash_ref: filename -> stats
# stats: [ lines_found, lines_hit, fn_found, fn_hit, br_found, br_hit,
#          link_name, line_rate, fn_rate, br_rate ]
#

sub get_sorted_keys($$)
{
        my ($hash, $type) = @_;

        if ($type == $SORT_FILE) {
                # Sort by name
                return sort(keys(%{$hash}));
        } elsif ($opt_missed) {
                return get_sorted_by_missed($hash, $type);
        } else {
                return get_sorted_by_rate($hash, $type);
        }
}

sub get_sort_code($$$)
{
        my ($link, $alt, $base) = @_;
        my $png;
        my $link_start;
        my $link_end;

        if (!defined($link)) {
                $png = "glass.png";
                $link_start = "";
                $link_end = "";
        } else {
                $png = "updown.png";
                $link_start = '<a href="'.$link.'">';
                $link_end = "</a>";
        }

        return ' <span class="tableHeadSort">'.$link_start.
               '<img src="'.$base.$png.'" width=10 height=14 '.
               'alt="'.$alt.'" title="'.$alt.'" border=0>'.$link_end.'</span>';
}

sub get_file_code($$$$)
{
        my ($type, $text, $sort_button, $base) = @_;
        my $result = $text;
        my $link;

        if ($sort_button) {
                if ($type == $HEAD_NO_DETAIL) {
                        $link = "index.$html_ext";
                } else {
                        $link = "index-detail.$html_ext";
                }
        }
        $result .= get_sort_code($link, "Sort by name", $base);

        return $result;
}

sub get_line_code($$$$$)
{
        my ($type, $sort_type, $text, $sort_button, $base) = @_;
        my $result = $text;
        my $sort_link;

        if ($type == $HEAD_NO_DETAIL) {
                # Just text
                if ($sort_button) {
                        $sort_link = "index-sort-l.$html_ext";
                }
        } elsif ($type == $HEAD_DETAIL_HIDDEN) {
                # Text + link to detail view
                $result .= ' ( <a class="detail" href="index-detail'.
                           $fileview_sortname[$sort_type].'.'.$html_ext.
                           '">show details</a> )';
                if ($sort_button) {
                        $sort_link = "index-sort-l.$html_ext";
                }
        } else {
                # Text + link to standard view
                $result .= ' ( <a class="detail" href="index'.
                           $fileview_sortname[$sort_type].'.'.$html_ext.
                           '">hide details</a> )';
                if ($sort_button) {
                        $sort_link = "index-detail-sort-l.$html_ext";
                }
        }
        # Add sort button
        $result .= get_sort_code($sort_link, "Sort by line coverage", $base);

        return $result;
}

sub get_func_code($$$$)
{
        my ($type, $text, $sort_button, $base) = @_;
        my $result = $text;
        my $link;

        if ($sort_button) {
                if ($type == $HEAD_NO_DETAIL) {
                        $link = "index-sort-f.$html_ext";
                } else {
                        $link = "index-detail-sort-f.$html_ext";
                }
        }
        $result .= get_sort_code($link, "Sort by function coverage", $base);
        return $result;
}

sub get_br_code($$$$)
{
        my ($type, $text, $sort_button, $base) = @_;
        my $result = $text;
        my $link;

        if ($sort_button) {
                if ($type == $HEAD_NO_DETAIL) {
                        $link = "index-sort-b.$html_ext";
                } else {
                        $link = "index-detail-sort-b.$html_ext";
                }
        }
        $result .= get_sort_code($link, "Sort by branch coverage", $base);
        return $result;
}

#
# write_file_table(filehandle, base_dir, overview, testhash, testfnchash,
#                  testbrhash, parentSummary, ctrlSettings)
#   ctrlSettings = [fileview, sort_type, details_type, sort_name]
#
# Write a complete file table. OVERVIEW is a reference to a hash containing
# the following mapping:
#
#   filename -> "lines_found,lines_hit,funcs_found,funcs_hit,page_link,
#                func_link" + other file details
#
# TESTHASH is a reference to the following hash:
#
#   filename -> \%testdata
#   %testdata: name of test affecting this file -> \%testcount
#   %testcount: line number -> execution count for a single test
#
# Heading of first column is "Filename" if FILEVIEW is true, "Directory name"
# otherwise.
#

sub write_file_table(*$$$$$$$)
{
  local *HTML_HANDLE = $_[0];
  my $base_dir = $_[1];
  my $overview = $_[2]; # hash of filename->file_summary
  my $testhash = $_[3];
  my $testfnchash = $_[4];
  my $testbrhash = $_[5];
  my $dirSummary = $_[6];
  my $ctrls = $_[7];
  # $fileview == 0 if listing directories, 1 if listing files
  # detail_type in ("", "-owner", "-date")
  my ($fileview, $sort_type, $detail_type, $sort_name) = @$ctrls;
  my $filename;
  my $bar_graph;
  my $hit;
  my $found;
  my $fn_found;
  my $fn_hit;
  my $br_found;
  my $br_hit;
  my $page_link;
  my $testname;
  my $testdata;
  my $testfncdata;
  my $testbrdata;
  my %affecting_tests;
  my $line_code = "";
  my $func_code;
  my $br_code;
  my $file_code;
  my @head_columns;

  # Determine HTML code for column headings
  if (($base_dir ne "") && $show_details)
  {
    my $detailed = keys(%{$testhash});

    $file_code = get_file_code($detailed ? $HEAD_DETAIL_HIDDEN :
                               $HEAD_NO_DETAIL,
                               $fileview ? "Filename" : "Directory",
                               $sort && $sort_type != $SORT_FILE,
                               $base_dir);
    $line_code = get_line_code($detailed ? $HEAD_DETAIL_SHOWN :
                               $HEAD_DETAIL_HIDDEN,
                               $sort_type,
                               "Line Coverage",
                               $sort && $sort_type != $SORT_LINE,
                               $base_dir);
    $func_code = get_func_code($detailed ? $HEAD_DETAIL_HIDDEN :
                               $HEAD_NO_DETAIL,
                               "Functions",
                               $sort && $sort_type != $SORT_FUNC,
                               $base_dir);
    $br_code = get_br_code($detailed ? $HEAD_DETAIL_HIDDEN :
                           $HEAD_NO_DETAIL,
                           "Branches",
                           $sort && $sort_type != $SORT_BRANCH,
                           $base_dir);
  } else {
    $file_code = get_file_code($HEAD_NO_DETAIL,
                               $fileview ? "Filename" : "Directory",
                               $sort && $sort_type != $SORT_FILE,
                               $base_dir);
    $line_code = get_line_code($HEAD_NO_DETAIL, $sort_type, "Line Coverage",
                               $sort && $sort_type != $SORT_LINE,
                               $base_dir);
    $func_code = get_func_code($HEAD_NO_DETAIL, "Functions",
                               $sort && $sort_type != $SORT_FUNC,
                               $base_dir);
    $br_code = get_br_code($HEAD_NO_DETAIL, "Branches",
                           $sort && $sort_type != $SORT_BRANCH,
                           $base_dir);
  }
  my @lineCovCols = (["coverage", 2], "Total", "Hit");
  my @branchCovCols = ("coverage", "Total", "Hit");
  if ($main::show_tla) {
    push(@lineCovCols, @SummaryInfo::tlaPriorityOrder);
    push(@branchCovCols, @SummaryInfo::tlaPriorityOrder);
  }
  push(@head_columns, [ $line_code, $#lineCovCols + 2, \@lineCovCols]);
  push(@head_columns, [ $br_code, $#branchCovCols + 1, \@branchCovCols])
    if ($br_coverage);
  push(@head_columns, [ $func_code, 2]) if ($func_coverage);

  my $showBinDetail = undef;
  if ($detail_type eq '-date' &&
      $dirSummary && $dirSummary->hasDateInfo()) {
    $showBinDetail = 'date';
  } elsif ($detail_type eq '-owner' &&
           $dirSummary && $dirSummary->hasOwnerInfo()) {
    $showBinDetail = 'owner';
  }
  write_file_table_prolog(*HTML_HANDLE, $file_code,
                          defined($showBinDetail) ? ucfirst($showBinDetail) : undef,
                          @head_columns);

  foreach $filename (get_sorted_keys($overview, $sort_type)) {

    # we need to find the 'owner' and 'date' row data for this file before
    #   we write anything else, because we need to know the number of
    #   rows that the $filename cell will span
    my $source; # a SourceFile object
    my $ownerBins; # developers who modified this file recently
    my $dateBins; # dates which contain code

    if (defined($showBinDetail)) {
      my $fullpath = ($dirSummary->{type} eq "top" ? "" : $dirSummary->{name} . "/") . $filename;
      if ( exists($dirSummary->{sources}->{$fullpath}) ) {
        $source = $dirSummary->{sources}->{$fullpath};

        if ($showBinDetail eq 'owner') {
          # do I need an option to suppress the list of owners?
          #  maybe too much information, in some circumstances?
          # are there any non-empty owner tables here?
          $ownerBins = $source->findOwnerList($main::show_ownerBins eq 'all');
        }

        if ($showBinDetail eq 'date') {
          for (my $bin=0 ; $bin <= $#SummaryInfo::ageGroupHeader ; ++ $bin) {
            my $ageval = $source->age_sample($bin);
            my $lineCbDate = DateDetailCallback->new($source, $ageval);
            my $lineTotal = $lineCbDate->get('found');

            my $branchCbDate = DateDetailCallback->new($source, $ageval,
                                                       'branch');
            my $branchTotal = $br_coverage ? $branchCbDate->get('found') : 0;

            next if 0 == $lineTotal && 0 == $branchTotal;

            $dateBins = [] if (!defined($dateBins));
            push(@$dateBins, [$ageval, $SummaryInfo::ageGroupHeader[$bin],
                              [$lineCbDate, $lineTotal],
                              [$branchCbDate, $branchTotal]]);
          }
        }
      }
    }

    my @columns;
    my ($lineRate, $funcRate, $branchRate, $fileSummary, $fileDetails);
    ($found, $hit, $fn_found, $fn_hit, $br_found, $br_hit, $page_link,
     $lineRate, $funcRate, $branchRate, $fileSummary, $fileDetails)
        = @{$overview->{$filename}};
    # a bit of a hack: if this is top-level page (such that the links
    #   are to directory pages rather than to source code detail pages)
    #   and this is the 'owner bin detail' (or the 'date bin detail') view,
    #   then link to the same 'bin detail' view of the directory page
    # This enables the user who is tracking down code written by a particular
    #   user (or on a particular date) to go link-to-link without having
    #   to select the 'bin' link in the destination header.
    if ($fileview == 0 &&
        $detail_type ne "") {
      $page_link =~ s/index.$html_ext$/index$detail_type.$html_ext/;
    }

    my @tableCallbackData = ($filename, $fileDetails, $page_link);
    my $showLineGraph = 1;
    # Line coverage
    push(@columns, [$found, $hit, $med_limit, $hi_limit, $showLineGraph,
                    $fileSummary, 'line']);
    # Branch coverage
    if ($br_coverage) {
      my $cbStruct = BranchCovSummaryCallback->new($fileSummary);
      push(@columns, [$br_found, $br_hit, $br_med_limit, $br_hi_limit, 0,
                      $cbStruct, 'branch']);
    }
    # Function coverage
    if ($func_coverage) {
        push(@columns, [$fn_found, $fn_hit, $fn_med_limit, $fn_hi_limit, 0,
                        undef, 'function']);
    }
    # pass 'dirSummary' to print method:  we omit the 'owner' column if
    #  none of the files in this directory have any owner information
    #  (i.e., none of them are found in the repo)
    my $numRows = (1
                   + (defined($ownerBins) ? scalar(@$ownerBins) : 0)
                   + (defined($dateBins) ? scalar(@$dateBins) : 0));

    write_file_table_entry(*HTML_HANDLE, $base_dir,
                           [$filename, \@tableCallbackData, $numRows,
                            "fileOrDir", $page_link, $dirSummary,
                            $showBinDetail],
                           @columns);

    if (defined($ownerBins)) {
      # print owners in order from most uncovered code
      foreach my $od (@$ownerBins) {
        my ($name, $line, $branch) = @$od;
        my ($lineMissed, $lineTotal) = @$line;
        my $lineHit = $lineTotal - $lineMissed;

        my $tmp = OwnerDetailCallback->new($source, $name);
        my @ownerColData;
        push(@ownerColData, [$lineTotal, $lineHit, $med_limit, $hi_limit,
                             $showLineGraph, $tmp, 'line']);
        if ($br_coverage) {
          my ($branchMissed, $branchTotal) = @$branch;
          my $brCallback = OwnerDetailCallback->new($source, $name, 'branch');
          # need to compute the totals...
          push(@ownerColData, [$branchTotal, $branchTotal - $branchMissed,
                               $br_med_limit, $br_hi_limit, 0,
                               $brCallback, 'branch']);
        }
        if ($func_coverage) {
          # not broken down by owner, yet
          push(@ownerColData, [0, 0]);
        }
        write_file_table_entry(*HTML_HANDLE, $base_dir,
                               # 'owner' page type - no span, no page link
                               [$name, \@tableCallbackData, 1,
                                "owner", undef],
                               @ownerColData);
      }
    }
    if (defined($dateBins)) {
      foreach my $dd (@$dateBins) {
        my ($ageVal, $ageLabel, $lineData, $branchData) = @$dd;
        my ($lineCbDate, $lineTotal) = @$lineData;
        my $lineHit = $lineCbDate->get('hit');
        my @dateColumnData;
        push(@dateColumnData, [$lineTotal, $lineHit, $med_limit, $hi_limit,
                               $showLineGraph, $lineCbDate, 'line']);

        if ($br_coverage) {
          my ($brCallback, $branchTotal) = @$branchData;
          # need to compute the totals...
          push(@dateColumnData, [$branchTotal,
                                 $brCallback->get("hit"),
                                 $br_med_limit, $br_hi_limit, 0,
                                 $brCallback, 'branch']);
        }
        if ($func_coverage) {
          # not broken down by owner, yet
          push(@dateColumnData, [0, 0]);
        }
        write_file_table_entry(*HTML_HANDLE, $base_dir,
                               # 'date' page type - no span, no page link
                               [$ageLabel, \@tableCallbackData,
                                1, "date", undef],
                               @dateColumnData);
      }
    }

    $testdata = $testhash->{$filename};
    $testfncdata = $testfnchash->{$filename};
    $testbrdata = $testbrhash->{$filename};

    # Check whether we should write test specific coverage as well
    if (!($show_details && $testdata)) { next; }

    # Filter out those tests that actually affect this file
    %affecting_tests = %{ get_affecting_tests($testdata,
                                              $testfncdata, $testbrdata) };

    # Does any of the tests affect this file at all?
    if (!%affecting_tests) { next; }

    foreach $testname (keys(%affecting_tests))
    {
      my @results;
      ($found, $hit, $fn_found, $fn_hit, $br_found, $br_hit) =
          split(",", $affecting_tests{$testname});

      # Insert link to description of available
      if ($test_description{$testname})
      {
        $testname = "<a href=\"$base_dir".
              "descriptions.$html_ext#$testname\">".
              "$testname</a>";
      }

      push(@results, [$found, $hit]);
      push(@results, [$fn_found, $fn_hit]) if ($func_coverage);
      push(@results, [$br_found, $br_hit]) if ($br_coverage);
      write_file_table_detail_entry(*HTML_HANDLE, $testname, @results);
    }
  }

  write_file_table_epilog(*HTML_HANDLE);
}


#
# get_found_and_hit(hash)
#
# Return the count for entries (found) and entries with an execution count
# greater than zero (hit) in a hash (linenumber -> execution count) as
# a list (found, hit)
#

sub get_found_and_hit($)
{
  my %hash = %{$_[0]};
  my $found = 0;
  my $hit = 0;

  # Calculate sum
  foreach (keys(%hash)) {
    $found++;
    $hit++
      if ($hash{$_} > 0);
  }
  return ($found, $hit);
}


#
# get_func_found_and_hit(sumfnccount)
#
# Return (f_found, f_hit) for sumfnccount
#

sub get_func_found_and_hit($)
{
  my ($sumfnccount) = @_;

  my $fn_found = scalar(keys(%{$sumfnccount}));
  my $fn_hit = 0;
  foreach my $function (keys(%{$sumfnccount})) {
    $fn_hit++
      if ($sumfnccount->{$function} > 0);
  }
  return ($fn_found, $fn_hit);
}


sub get_br_found_and_hit($)
{
  my ($brcount) = @_;

  my $db = brcount_to_db($brcount);

  return brcount_db_get_found_and_hit($db);
}


#
# get_affecting_tests(testdata, testfncdata, testbrdata)
#
# HASHREF contains a mapping filename -> (linenumber -> exec count). Return
# a hash containing mapping filename -> "lines found, lines hit" for each
# filename which has a nonzero hit count.
#

sub get_affecting_tests($$$)
{
  my ($testdata, $testfncdata, $testbrdata) = @_;
  my %result;

  foreach my $testname (keys(%{$testdata})) {
    # Get (line number -> count) hash for this test case
    my $testcount = $testdata->{$testname};
    my $testfnccount = $testfncdata->{$testname};
    my $testbrcount = $testbrdata->{$testname};

    # Calculate sum
    my ($found, $hit) = get_found_and_hit($testcount);
    my ($fn_found, $fn_hit) = get_func_found_and_hit($testfnccount);
    my ($br_found, $br_hit) = get_br_found_and_hit($testbrcount);

    $result{$testname} = "$found,$hit,$fn_found,$fn_hit,$br_found,$br_hit"
      if ($hit > 0);
  }
  return(\%result);
}


sub get_hash_reverse($)
{
  my ($hash) = @_;
  my %result;

  foreach (keys(%{$hash})) {
    $result{$hash->{$_}} = $_;
  }

  return \%result;
}

#
# write_source(filehandle, source_filename, count_data, checksum_data,
#              converted_data, func_data, sumbrcount)
#
# Write an HTML view of a source code file. Returns a list containing
# data as needed by gen_png().
#
# Die on error.
#

sub write_source($$$$$$$)
{
  local *HTML_HANDLE = $_[0];
  #local *SOURCE_HANDLE;
  my $srcfile = $_[1];
  my $count_data;
  my $line_number;
  my @result;
  my $checkdata = $_[3];
  my $lineCovInfo = $_[4];
  my $funcdata  = $_[5];
  my $sumbrcount = $_[6];
  my $datafunc = get_hash_reverse($funcdata);
  my @file;

  if ($_[2]) {
    $count_data = $_[2];
  }

  write_source_prolog(*HTML_HANDLE, $srcfile->isProjectFile());
  $line_number = 0;
  my $cbdata = PrintCallback->new($srcfile, $lineCovInfo);

  foreach my $srcline (@{$srcfile->lines()}) {
    $line_number++;
    $cbdata->lineNo($line_number);

    # Source code matches coverage data?
    die("ERROR: checksum mismatch  at ".$srcfile->path(). ":$line_number\n")
      if (defined($checkdata->value($line_number)) &&
          ($checkdata->value($line_number) ne md5_base64($srcline->text())));
    push (@result, write_source_line(HTML_HANDLE, $srcline,
                                     $count_data->value($line_number),
                                     $sumbrcount->value($line_number),
                                     $cbdata));
  }
  write_source_epilog(*HTML_HANDLE);
  return(@result);
}


sub funcview_get_func_code($$$)
{
  my ($name, $base, $type) = @_;
  my $link;

  if ($sort && $type == 1) {
    $link = "$name.func.$html_ext";
  }
  my $result = "Function Name" . get_sort_code($link,
                                               "Sort by function name", $base);
  return $result;
}

sub funcview_get_count_code($$$)
{
  my ($name, $base, $type) = @_;
  my $link;

  if ($sort && $type == 0) {
    $link = "$name.func-sort-c.$html_ext";
  }
  my $result = "Hit count" . get_sort_code($link, "Sort by hit count", $base);
  return $result;
}

#
# funcview_get_sorted(funcdata, sumfncdata, sort_type)
#
# Depending on the value of sort_type, return a list of functions sorted
# by name (type 0) or by the associated call count (type 1).
#

sub funcview_get_sorted($$$)
{
        my ($funcdata, $sumfncdata, $type) = @_;

        if ($type == 0) {
                return sort($funcdata->keylist());
        }
        return sort({
                $sumfncdata->value($b) == $sumfncdata->value($a) ?
                        $a cmp $b : $sumfncdata->value($a) <=> $sumfncdata->value($b)
                } $sumfncdata->keylist());
}

sub demangle_list($)
{
        my ($list) = @_;
        my $tmpfile;
        my $handle;
        my %demangle;
        my $demangle_arg = "";
        my %versions;

        # Write function names to file
        ($handle, $tmpfile) = tempfile();
        die("ERROR: could not create temporary file") if (!defined($tmpfile));
        print($handle join("\n", @$list));
        close($handle);

        # Extra flag necessary on OS X so that symbols listed by gcov get demangled
        # properly.
        if ($^O eq "darwin") {
                $demangle_arg = "--no-strip-underscores";
        }

        # Build translation hash from c++filt output
        open($handle, "-|", "c++filt $demangle_arg < $tmpfile") or
                die("ERROR: could not run c++filt: $!\n");
        foreach my $func (@$list) {
                my $translated = <$handle>;
                my $version;

                last if (!defined($translated));
                chomp($translated);

                $version = ++$versions{$translated};
                $translated .= ".$version" if ($version > 1);
                $demangle{$func} = $translated;
        }
        close($handle);

        if (scalar(keys(%demangle)) != scalar(@$list)) {
                die("ERROR: c++filt output not as expected (".
                    scalar(keys(%demangle))." vs ".scalar(@$list).") lines\n");
        }

        unlink($tmpfile) or
                warn("WARNING: could not remove temporary file $tmpfile: $!\n");

        return \%demangle;
}

#
# write_function_table(filehandle, source_file, sumcount, funcdata,
#                      sumfnccount, testfncdata, sumbrcount, testbrdata,
#                      base_name, base_dir, sort_type)
#
# Write an HTML table listing all functions in a source file, including
# also function call counts and line coverages inside of each function.
#
# Die on error.
#

sub write_function_table(*$$$$$$$$$$)
{
        local *HTML_HANDLE = $_[0];
        my $source = $_[1];
        my $sumcount = $_[2];
        my $funcdata = $_[3];
        my $sumfncdata = $_[4];
        my $testfncdata = $_[5];
        my $sumbrcount = $_[6];
        my $testbrdata = $_[7];
        my $name = $_[8];
        my $base = $_[9];
        my $type = $_[10];
        my $func;
        my $func_code;
        my $count_code;
        my $demangle;

        # Get HTML code for headings
        $func_code = funcview_get_func_code($name, $base, $type);
        $count_code = funcview_get_count_code($name, $base, $type);
        write_html(*HTML_HANDLE, <<END_OF_HTML);
          <center>
          <table width="60%" cellpadding=1 cellspacing=1 border=0>
            <tr><td><br></td></tr>
            <tr>
              <td width="80%" class="tableHead">$func_code</td>
              <td width="20%" class="tableHead">$count_code</td>
            </tr>
END_OF_HTML

        # Get demangle translation hash
        if ($demangle_cpp) {
                $demangle = demangle_list([ sort($funcdata->keylist()) ]);
        }

        # Get a sorted table
        foreach $func (funcview_get_sorted($funcdata, $sumfncdata, $type)) {
                if (!$funcdata->mapped($func))
                {
                        next;
                }

                my $startline = $funcdata->value($func) - $func_offset;
                my $name = $func;
                my $count = $sumfncdata->value($name);
                my $countstyle;

                # Replace function name with demangled version if available
                $name = $demangle->{$name} if (exists($demangle->{$name}));

                # Escape special characters
                $name = escape_html($name);
                if ($startline < 1) {
                        $startline = 1;
                }
                if ($count == 0) {
                        $countstyle = "coverFnLo";
                } else {
                        $countstyle = "coverFnHi";
                }

                write_html(*HTML_HANDLE, <<END_OF_HTML);
            <tr>
              <td class="coverFn"><a href="$source#$startline">$name</a></td>
              <td class="$countstyle">$count</td>
            </tr>
END_OF_HTML
        }
        write_html(*HTML_HANDLE, <<END_OF_HTML);
          </table>
          <br>
          </center>
END_OF_HTML
}


#
# subtract_counts(data_ref, base_ref)
#

sub subtract_counts($$)
{
  my %data = %{$_[0]};
  my %base = %{$_[1]};
  my $hit = 0;
  my $found = 0;

  foreach my $line (keys(%data)) {
    $found++;
    my $data_count = $data{$line};
    my $base_count = $base{$line};

    if (defined($base_count)) {
      $data_count -= $base_count;

      # Make sure we don't get negative numbers
      if ($data_count<0) {
        $data_count = 0; }
    }

    $data{$line} = $data_count;
    if ($data_count > 0) {
      $hit++;
    }
  }
  return (\%data, $found, $hit);
}


#
# subtract_fnccounts(data, base)
#
# Subtract function call counts found in base from those in data.
# Return (data, f_found, f_hit).
#

sub subtract_fnccounts($$)
{
  my $fn_hit = 0;
  my $fn_found = 0;

  my %data = %{$_[0]} if (defined($_[0]));
  my %base = %{$_[1]} if (defined($_[1]));
  foreach my $func (keys(%data)) {
    $fn_found++;
    my $data_count = $data{$func};
    my $base_count = $base{$func};

    if (defined($base_count)) {
      $data_count -= $base_count;

      # Make sure we don't get negative numbers
      if ($data_count < 0) {
        $data_count = 0;
      }
    }
    $data{$func} = $data_count;
    if ($data_count > 0) {
      $fn_hit++;
    }
  }
  return (\%data, $fn_found, $fn_hit);
}


#
# apply_baseline(data_ref, baseline_ref)
#
# Subtract the execution counts found in the baseline hash referenced by
# BASELINE_REF from actual data in DATA_REF.
#

sub apply_baseline($$)
{
  my %data_hash = %{$_[0]};
  my %base_hash = %{$_[1]};
  my $data_testdata;
  my $data_funcdata;
  my $data_checkdata;
  my $data_testfncdata;
  my $data_testbrdata;

  my $base_checkdata;
  my $base_sumfnccount;
  my $base_sumbrcount;
  my $base_count;
  my $found;
  my $hit;
  my $fn_found;
  my $fn_hit;
  my $br_found;
  my $br_hit;

  foreach my $filename (keys(%data_hash)) {
    # Get data set for data and baseline
    my $data = $data_hash{$filename};
    my $base = $base_hash{$filename};

    # Skip data entries for which no base entry exists
    next
      if (!defined($base));

    # Get set entries for data and baseline
    ($data_testdata, undef, $data_funcdata, $data_checkdata,
     $data_testfncdata, undef, $data_testbrdata) =
         get_info_entry($data);
    (undef, $base_count, undef, $base_checkdata, undef,
     $base_sumfnccount, undef, $base_sumbrcount) =
         get_info_entry($base);

    # Check for compatible checksums
    merge_checksums($data_checkdata, $base_checkdata, $filename);

    # sumcount has to be calculated anew
    my $sumcount = {};
    my $sumfnccount = {};
    my $sumbrcount = {};

    # For each test case, subtract test specific counts
    foreach my $testname (keys(%{$data_testdata})) {
      # Get counts of both data and baseline
      my $data_count = $data_testdata->{$testname};
      my $data_testfnccount = $data_testfncdata->{$testname};
      my $data_testbrcount = $data_testbrdata->{$testname};

      ($data_count, undef, $hit) = subtract_counts($data_count, $base_count);
      ($data_testfnccount) = subtract_fnccounts($data_testfnccount,
                                                $base_sumfnccount);
      ($data_testbrcount) = combine_brcount($data_testbrcount,
                                            $base_sumbrcount, $BR_SUB);

      # Check whether this test case did hit any line at all
      if ($hit > 0) {
        # Write back resulting hash
        $data_testdata->{$testname} = $data_count;
        $data_testfncdata->{$testname} = $data_testfnccount;
        $data_testbrdata->{$testname} = $data_testbrcount;
      }
      else {
        # Delete test case which did not impact this file
        delete($data_testdata->{$testname});
        delete($data_testfncdata->{$testname});
        delete($data_testbrdata->{$testname});
      }

      # Add counts to sum of counts
      ($sumcount, $found, $hit) = add_counts($sumcount, $data_count);
      ($sumfnccount, $fn_found, $fn_hit) = add_fnccount($sumfnccount,
                                                        $data_testfnccount);
      ($sumbrcount, $br_found, $br_hit) = combine_brcount($sumbrcount,
                                                          $data_testbrcount,
                                                          $BR_ADD);
    }

    # Write back resulting entry
    set_info_entry($data, $data_testdata, $sumcount, $data_funcdata,
                   $data_checkdata, $data_testfncdata, $sumfnccount,
                   $data_testbrdata, $sumbrcount, $found, $hit,
                   $fn_found, $fn_hit, $br_found, $br_hit);

    $data_hash{$filename} = $data;
  }

  return (\%data_hash);
}


#
# remove_unused_descriptions()
#
# Removes all test descriptions from the global hash %test_description which
# are not present in %current_data.
#

sub remove_unused_descriptions()
{
  my $filename;           # The current filename
  my %test_list;          # Hash containing found test names
  my $test_data;          # Reference to hash test_name -> count_data
  my $before;             # Initial number of descriptions
  my $after;              # Remaining number of descriptions

  $before = scalar(keys(%test_description));

  foreach $filename ($current_data->files()) {
    ($test_data) = $current_data->data($filename)->get_info();
    foreach ($test_data->keylist()) {
      $test_list{$_} = "";
    }
  }

  # Remove descriptions for tests which are not in our list
  foreach (keys(%test_description)) {
    if (!defined($test_list{$_})) {
        delete($test_description{$_});
    }
  }

  $after = scalar(keys(%test_description));
  if ($after < $before) {
      info("Removed ".($before - $after).
           " unused descriptions, $after remaining.\n");
  }
}


#
# apply_prefix(filename, PREFIXES)
#
# If FILENAME begins with PREFIX from PREFIXES, remove PREFIX from FILENAME
# and return resulting string, otherwise return FILENAME.
#

sub apply_prefix($@)
{
  my $filename = shift;
  my @dir_prefix = @_;

  if (@dir_prefix) {
     foreach my $prefix (@dir_prefix) {
       if ($prefix ne "" && $filename =~ /^\Q$prefix\E\/(.*)$/) {
         return substr($filename, length($prefix) + 1);
       }
     }
  }
  return $filename;
}


#
# read_config(filename)
#
# Read configuration file FILENAME and return a reference to a hash containing
# all valid key=value pairs found.
#

sub read_config($)
{
        my $filename = $_[0];
        my %result;
        my $key;
        my $value;
        local *HANDLE;

        if (!open(HANDLE, "<", $filename))
        {
                warn("WARNING: cannot read configuration file $filename\n");
                return undef;
        }
        while (<HANDLE>)
        {
                chomp;
                # Skip comments
                s/#.*//;
                # Remove leading blanks
                s/^\s+//;
                # Remove trailing blanks
                s/\s+$//;
                next unless length;
                ($key, $value) = split(/\s*=\s*/, $_, 2);
                if (defined($key) && defined($value))
                {
                        $result{$key} = $value;
                }
                else
                {
                        warn("WARNING: malformed statement in line $. ".
                             "of configuration file $filename\n");
                }
        }
        close(HANDLE);
        return \%result;
}


#
# apply_config(REF)
#
# REF is a reference to a hash containing the following mapping:
#
#   key_string => var_ref
#
# where KEY_STRING is a keyword and VAR_REF is a reference to an associated
# variable. If the global configuration hashes CONFIG or OPT_RC contain a value
# for keyword KEY_STRING, VAR_REF will be assigned the value for that keyword.
#

sub apply_config($)
{
        my $ref = $_[0];

        foreach (keys(%{$ref}))
        {
                if (defined($opt_rc{$_})) {
                        ${$ref->{$_}} = $opt_rc{$_};
                } elsif (defined($config->{$_})) {
                        ${$ref->{$_}} = $config->{$_};
                }
        }
}


#
# get_html_prolog(FILENAME)
#
# If FILENAME is defined, return contents of file. Otherwise return default
# HTML prolog. Die on error.
#

sub get_html_prolog($)
{
  my $filename = $_[0];
  my $result = "";

  if (defined($filename)) {
    local *HANDLE;

    open(HANDLE, "<", $filename)
      or die("ERROR: cannot open html prolog $filename!\n");
    while (<HANDLE>) {
      $result .= $_;
    }
    close(HANDLE);
  } else {
    $result = <<END_OF_HTML;
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=$charset">
  <title>\@pagetitle\@</title>
  <link rel="stylesheet" type="text/css" href="\@basedir\@gcov.css">
</head>

<body>

END_OF_HTML
  }
  return $result;
}


#
# get_html_epilog(FILENAME)
#
# If FILENAME is defined, return contents of file. Otherwise return default
# HTML epilog. Die on error.
#
sub get_html_epilog($)
{
  my $filename = $_[0];
  my $result = "";

  if (defined($filename)) {
    local *HANDLE;

    open(HANDLE, "<", $filename)
      or die("ERROR: cannot open html epilog $filename!\n");
    while (<HANDLE>) {
      $result .= $_;
    }
    close(HANDLE);
  } else {
    $result = <<END_OF_HTML;

</body>
</html>
END_OF_HTML
  }

  return $result;
}


#
# parse_dir_prefix(@dir_prefix)
#
# Parse user input about the prefix list
#

sub parse_dir_prefix(@)
{
  my (@opt_dir_prefix) = @_;

  return if (!@opt_dir_prefix);

  foreach my $item (@opt_dir_prefix) {
    if ($item =~ /,/) {
      # Split and add comma-separated parameters
      push(@dir_prefix, split(/,/, $item));
    } else {
      # Add single parameter
      push(@dir_prefix, $item);
    }
  }
}

#
# rate(hit, found[, suffix, precision, width])
#
# Return the coverage rate [0..100] for HIT and FOUND values. 0 is only
# returned when HIT is 0. 100 is only returned when HIT equals FOUND.
# PRECISION specifies the precision of the result. SUFFIX defines a
# string that is appended to the result if FOUND is non-zero. Spaces
# are added to the start of the resulting string until it is at least WIDTH
# characters wide.
#

sub rate($$;$$$)
{
  my ($hit, $found, $suffix, $precision, $width) = @_;
  my $rate;

  # Assign defaults if necessary
  $precision      = $default_precision if (!defined($precision));
  $suffix         = ""    if (!defined($suffix));
  $width          = 0     if (!defined($width));

  return sprintf("%*s", $width, "-") if (!defined($found) || $found == 0);
  $rate = sprintf("%.*f", $precision, $hit * 100 / $found);

  # Adjust rates if necessary
  if ($rate == 0 && $hit > 0) {
    $rate = sprintf("%.*f", $precision, 1 / 10 ** $precision);
  } elsif ($rate == 100 && $hit != $found) {
    $rate = sprintf("%.*f", $precision, 100 - 1 / 10 ** $precision);
  }

  return sprintf("%*s", $width, $rate.$suffix);
}
